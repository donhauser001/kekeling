# 弹窗开发规范文档

本文档定义了后台管理系统弹窗组件的统一开发规范，确保所有弹窗在布局、交互和代码结构上保持一致。

## 目录

- [弹窗类型选择](#弹窗类型选择)
- [Dialog vs Sheet 决策指南](#dialog-vs-sheet-决策指南)
- [核心依赖](#核心依赖)
- [表单弹窗规范（Dialog）](#表单弹窗规范dialog)
- [抽屉弹窗规范（Sheet）](#抽屉弹窗规范sheet)
- [多板块弹窗规范](#多板块弹窗规范)
- [确认弹窗规范](#确认弹窗规范)
- [表单验证](#表单验证)
- [输入组件](#输入组件)
- [交互体验增强](#交互体验增强)
- [数据加载与错误处理](#数据加载与错误处理)
- [响应式与移动端适配](#响应式与移动端适配)
- [弹窗文件分离规范](#弹窗文件分离规范)
- [完整示例](#完整示例)
- [常见问题与反模式](#常见问题与反模式)
- [检查清单](#检查清单)

---

## 弹窗类型选择

### 组件类型总览

| 类型 | 用途 | 组件 | 宽度 |
|------|------|------|------|
| **简单表单弹窗** | 邀请/快捷操作（≤5字段） | `Dialog` | `sm:max-w-md` |
| **标准表单弹窗** | 新建/编辑实体（6-15字段） | `Dialog` | `sm:max-w-lg` |
| **复杂表单抽屉** | 多板块配置/详情（>15字段） | `Sheet` + `Tabs` | 侧边全高 |
| **确认弹窗** | 删除/危险操作确认 | `ConfirmDialog` | 默认 |
| **详情抽屉** | 查看详情/只读 | `Sheet` | 侧边全高 |
| **配置抽屉** | 全局/模块级配置 | `Sheet` | 侧边全高 |

---

## Dialog vs Sheet 决策指南

### Dialog（模态窗）适用场景

| 场景 | 说明 | 示例 |
|------|------|------|
| **阻断式操作** | 必须完成当前操作才能继续 | 删除确认、提交审核 |
| **创建实体** | 新建一条独立记录 | 新建用户、新建活动 |
| **简单编辑** | 字段少，快速完成 | 修改名称、调整状态 |
| **表单提交** | 有明确的提交动作 | 邀请用户、发送通知 |
| **字段数量** | ≤15 个字段 | - |

**特点**：聚焦、阻断、强制完成

### Sheet（抽屉）适用场景

| 场景 | 说明 | 示例 |
|------|------|------|
| **配置/设置** | 全局或模块级配置 | 分销配置、主题设置 |
| **详情查看** | 只读或部分可编辑 | 订单详情、用户资料 |
| **复杂表单** | 多板块、多步骤 | 服务编辑、商品编辑 |
| **需要参考** | 操作时需看主页面 | 批量操作、数据对比 |
| **辅助面板** | 不完全阻断主流程 | 筛选器、帮助面板 |
| **字段数量** | >15 个字段或多板块 | - |

**特点**：宽敞、可参考、渐进式

### 决策流程

```
开始
  │
  ├─ 是否为确认/警告操作？ ──是──→ Dialog（ConfirmDialog）
  │
  ├─ 是否为配置/设置类？ ──是──→ Sheet（抽屉）
  │
  ├─ 是否需要参考主页面？ ──是──→ Sheet（抽屉）
  │
  ├─ 字段数量 > 15 或多板块？ ──是──→ Sheet + Tabs（抽屉+分页）
  │
  ├─ 是否为详情查看？ ──是──→ Sheet（抽屉）
  │
  └─ 其他（创建/编辑/提交） ──→ Dialog（模态窗）
```

### 具体业务场景映射

| 业务场景 | 推荐类型 | 理由 |
|---------|---------|------|
| 新建/编辑员工 | Dialog | 字段适中，聚焦操作 |
| 新建/编辑活动 | Dialog | 单一实体，需要完成 |
| 删除确认 | Dialog (Confirm) | 阻断式，强制确认 |
| 分销配置 | Sheet + Tabs | 多板块配置 |
| 服务详情编辑 | Sheet + Tabs | 字段多，需要分组 |
| 订单详情 | Sheet | 查看为主，可部分操作 |
| 主题设置 | Sheet | 配置类，可随时调整 |
| 筛选面板 | Sheet | 辅助功能，不阻断 |
| 邀请用户 | Dialog | 简单表单，明确提交 |
| 权限设置 | Dialog / Sheet | 看复杂度，简单用 Dialog |

### 编辑与查看分离原则

**重要规范**：编辑操作和查看操作不可混用同一个弹窗。

| 操作类型 | 推荐组件 | 说明 |
|---------|---------|------|
| **新建** | Dialog | 空表单，聚焦填写 |
| **编辑** | Dialog | 预填数据，聚焦修改 |
| **查看详情** | Sheet | 只读展示，信息量大时使用抽屉 |

#### 为什么要分离？

1. **用户意图明确**：编辑是"修改"，查看是"了解"，混用会模糊用户意图
2. **防止误操作**：查看时误触提交，可能导致数据被意外修改
3. **信息展示优化**：查看详情往往需要展示更多信息（如操作日志、关联数据），用抽屉更合适
4. **交互一致性**：统一"查看用抽屉，编辑用弹窗"的交互模式

#### 操作列菜单设计

```tsx
<DropdownMenuContent align='end' className='w-[160px]'>
  <DropdownMenuItem onClick={() => onView(item)}>
    查看详情
    <DropdownMenuShortcut><Eye size={16} /></DropdownMenuShortcut>
  </DropdownMenuItem>
  <DropdownMenuItem onClick={() => onEdit(item)}>
    编辑
    <DropdownMenuShortcut><Pencil size={16} /></DropdownMenuShortcut>
  </DropdownMenuItem>
  <DropdownMenuSeparator />
  <DropdownMenuItem onClick={() => onDelete(item.id)} className='text-red-500!'>
    删除
    <DropdownMenuShortcut><Trash2 size={16} /></DropdownMenuShortcut>
  </DropdownMenuItem>
</DropdownMenuContent>
```

#### 详情抽屉结构

```tsx
<Sheet open={viewOpen} onOpenChange={setViewOpen}>
  <SheetContent className='w-[500px] sm:max-w-[500px]'>
    <SheetHeader>
      <SheetTitle>项目详情</SheetTitle>
      <SheetDescription>查看项目的详细信息</SheetDescription>
    </SheetHeader>
    
    <div className='space-y-6 py-4'>
      {/* 基础信息区 */}
      <div className='space-y-2'>
        <h4 className='text-sm font-medium text-muted-foreground'>基础信息</h4>
        <dl className='grid grid-cols-2 gap-2 text-sm'>
          <dt className='text-muted-foreground'>名称</dt>
          <dd>{item.name}</dd>
          <dt className='text-muted-foreground'>状态</dt>
          <dd><Badge variant='outline'>{item.status}</Badge></dd>
          {/* 更多字段... */}
        </dl>
      </div>
      
      {/* 其他信息区 */}
      <div className='space-y-2'>
        <h4 className='text-sm font-medium text-muted-foreground'>操作记录</h4>
        {/* 日志列表... */}
      </div>
    </div>
    
    <SheetFooter>
      <Button variant='outline' onClick={() => setViewOpen(false)}>
        关闭
      </Button>
      <Button onClick={() => { setViewOpen(false); onEdit(item); }}>
        编辑
      </Button>
    </SheetFooter>
  </SheetContent>
</Sheet>
```

---

## 核心依赖

```tsx
// 表单库
import { z } from 'zod'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'

// 表单组件
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form'

// Dialog 弹窗组件
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogClose,
} from '@/components/ui/dialog'

// Sheet 抽屉组件
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from '@/components/ui/sheet'

// 分页组件（多板块时使用）
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'

// 输入组件
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Switch } from '@/components/ui/switch'
import { PasswordInput } from '@/components/password-input'
import { SelectDropdown } from '@/components/select-dropdown'

// 确认弹窗
import { ConfirmDialog } from '@/components/confirm-dialog'
```

---

## 表单弹窗规范（Dialog）

### 标准表单弹窗（新建/编辑）

适用于字段较多的实体编辑场景。

#### 布局特点

- **弹窗宽度**：`sm:max-w-lg`
- **表单布局**：水平布局 `grid grid-cols-6`
- **标签位置**：右对齐 `col-span-2 text-end`
- **输入框位置**：`col-span-4`
- **内容区域**：响应式高度滚动 `max-h-[60vh] min-h-[300px] overflow-y-auto`
- **提交方式**：form id 关联 Footer 按钮

> ⚠️ **高度规范**：避免使用固定像素高度（如 `h-[26.25rem]`），在小屏设备上会导致弹窗超出视口或留白过多。推荐使用 `vh` 单位结合 `min-height` 限制。

#### 结构模板

```tsx
<Dialog
  open={open}
  onOpenChange={(state) => {
    form.reset()
    onOpenChange(state)
  }}
>
  <DialogContent className='sm:max-w-lg'>
    <DialogHeader className='text-start'>
      <DialogTitle>{isEdit ? '编辑项目' : '新建项目'}</DialogTitle>
      <DialogDescription>
        {isEdit ? '在此处更新项目信息。' : '在此处创建新项目。'}
        完成后点击保存。
      </DialogDescription>
    </DialogHeader>

    {/* 响应式高度滚动区域 */}
    <div className='max-h-[60vh] min-h-[300px] overflow-y-auto py-1 px-1'>
      <Form {...form}>
        <form
          id='entity-form'
          onSubmit={form.handleSubmit(onSubmit)}
          className='space-y-4 px-0.5'
        >
          {/* 表单字段 */}
        </form>
      </Form>
    </div>

    <DialogFooter>
      <Button type='submit' form='entity-form'>
        保存
      </Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

#### 字段布局模板

```tsx
<FormField
  control={form.control}
  name='fieldName'
  render={({ field }) => (
    <FormItem className='grid grid-cols-6 items-center space-y-0 gap-x-4 gap-y-1'>
      <FormLabel className='col-span-2 text-end'>字段标签</FormLabel>
      <FormControl>
        <Input
          placeholder='请输入...'
          className='col-span-4'
          autoComplete='off'
          {...field}
        />
      </FormControl>
      <FormMessage className='col-span-4 col-start-3' />
    </FormItem>
  )}
/>
```

---

### 简单表单弹窗（邀请/快捷操作）

适用于字段较少的快捷操作场景。

#### 布局特点

- **弹窗宽度**：`sm:max-w-md`
- **表单布局**：垂直布局（标签在上，输入框在下）
- **表单间距**：`space-y-4`
- **Footer**：包含取消按钮 + 提交按钮

#### 结构模板

```tsx
<Dialog
  open={open}
  onOpenChange={(state) => {
    form.reset()
    onOpenChange(state)
  }}
>
  <DialogContent className='sm:max-w-md'>
    <DialogHeader className='text-start'>
      <DialogTitle className='flex items-center gap-2'>
        <IconComponent /> 操作标题
      </DialogTitle>
      <DialogDescription>
        操作描述文字，说明用途和注意事项。
      </DialogDescription>
    </DialogHeader>

    <Form {...form}>
      <form
        id='action-form'
        onSubmit={form.handleSubmit(onSubmit)}
        className='space-y-4'
      >
        {/* 表单字段 */}
      </form>
    </Form>

    <DialogFooter className='gap-y-2'>
      <DialogClose asChild>
        <Button variant='outline'>取消</Button>
      </DialogClose>
      <Button type='submit' form='action-form'>
        确认操作
      </Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

#### 字段布局模板

```tsx
<FormField
  control={form.control}
  name='fieldName'
  render={({ field }) => (
    <FormItem>
      <FormLabel>字段标签</FormLabel>
      <FormControl>
        <Input placeholder='请输入...' {...field} />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

---

## 抽屉弹窗规范（Sheet）

### 基础抽屉结构

适用于配置、设置、详情查看等场景。

```tsx
<Sheet open={open} onOpenChange={onOpenChange}>
  <SheetContent className='flex flex-col'>
    <SheetHeader className='text-start'>
      <SheetTitle>抽屉标题</SheetTitle>
      <SheetDescription>
        抽屉描述文字，说明用途和注意事项。
      </SheetDescription>
    </SheetHeader>

    {/* 滚动内容区 */}
    <div className='flex-1 space-y-6 overflow-y-auto px-4'>
      <SectionA />
      <SectionB />
      <SectionC />
    </div>

    <SheetFooter className='gap-2'>
      <Button variant='outline' onClick={() => onOpenChange(false)}>
        取消
      </Button>
      <Button onClick={handleSave}>
        保存
      </Button>
    </SheetFooter>
  </SheetContent>
</Sheet>
```

### 抽屉内分组标题

```tsx
function SectionTitle({ title }: { title: string }) {
  return (
    <div className='text-muted-foreground mb-2 text-sm font-semibold'>
      {title}
    </div>
  )
}

// 使用
<div>
  <SectionTitle title='基础设置' />
  {/* 该分组的内容 */}
</div>
```

---

## 多板块弹窗规范

### Tabs + Dialog 模式

适用于字段较多但仍需要聚焦完成的场景。

```tsx
<Dialog open={open} onOpenChange={onOpenChange}>
  <DialogContent className='max-w-3xl max-h-[90vh] overflow-y-auto'>
    <DialogHeader>
      <DialogTitle>配置标题</DialogTitle>
      <DialogDescription>配置描述文字</DialogDescription>
    </DialogHeader>

    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className='space-y-6'>
        <Tabs defaultValue='tab1' className='w-full'>
          <TabsList className='grid w-full grid-cols-3'>
            <TabsTrigger value='tab1'>板块1</TabsTrigger>
            <TabsTrigger value='tab2'>板块2</TabsTrigger>
            <TabsTrigger value='tab3'>板块3</TabsTrigger>
          </TabsList>

          <TabsContent value='tab1' className='space-y-4 mt-4'>
            <Card>
              <CardHeader>
                <CardTitle className='text-base'>分组标题</CardTitle>
                <CardDescription>分组描述</CardDescription>
              </CardHeader>
              <CardContent className='grid gap-4 md:grid-cols-2'>
                {/* 表单字段 */}
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value='tab2' className='space-y-4 mt-4'>
            {/* 板块2内容 */}
          </TabsContent>

          <TabsContent value='tab3' className='space-y-4 mt-4'>
            {/* 板块3内容 */}
          </TabsContent>
        </Tabs>

        <DialogFooter>
          <Button type='button' variant='outline' onClick={() => onOpenChange(false)}>
            取消
          </Button>
          <Button type='submit' disabled={isPending}>
            {isPending && <Loader2 className='mr-2 h-4 w-4 animate-spin' />}
            保存
          </Button>
        </DialogFooter>
      </form>
    </Form>
  </DialogContent>
</Dialog>
```

### Tabs + Sheet 模式

适用于复杂配置、需要大量空间的场景。

```tsx
<Sheet open={open} onOpenChange={onOpenChange}>
  <SheetContent className='w-[600px] sm:max-w-[600px] flex flex-col'>
    <SheetHeader>
      <SheetTitle>配置标题</SheetTitle>
      <SheetDescription>配置描述文字</SheetDescription>
    </SheetHeader>

    <Form {...form}>
      <form
        onSubmit={form.handleSubmit(onSubmit)}
        className='flex flex-1 flex-col overflow-hidden'
      >
        <Tabs defaultValue='tab1' className='flex flex-1 flex-col overflow-hidden'>
          <TabsList className='grid w-full grid-cols-3'>
            <TabsTrigger value='tab1'>板块1</TabsTrigger>
            <TabsTrigger value='tab2'>板块2</TabsTrigger>
            <TabsTrigger value='tab3'>板块3</TabsTrigger>
          </TabsList>

          <div className='flex-1 overflow-y-auto py-4'>
            <TabsContent value='tab1' className='space-y-4 mt-0'>
              <Card>
                <CardHeader>
                  <CardTitle className='text-base'>分组标题</CardTitle>
                  <CardDescription>分组描述</CardDescription>
                </CardHeader>
                <CardContent className='grid gap-4'>
                  {/* 表单字段 */}
                </CardContent>
              </Card>
            </TabsContent>

            <TabsContent value='tab2' className='space-y-4 mt-0'>
              {/* 板块2内容 */}
            </TabsContent>
          </div>
        </Tabs>

        <SheetFooter className='pt-4'>
          <Button type='button' variant='outline' onClick={() => onOpenChange(false)}>
            取消
          </Button>
          <Button type='submit' disabled={isPending}>
            保存
          </Button>
        </SheetFooter>
      </form>
    </Form>
  </SheetContent>
</Sheet>
```

### Card 内字段布局

多板块弹窗中，Card 内的字段使用垂直布局 + Grid 排列：

```tsx
<Card>
  <CardHeader>
    <CardTitle className='text-base'>分组标题</CardTitle>
    <CardDescription>分组描述说明</CardDescription>
  </CardHeader>
  <CardContent className='grid gap-4 md:grid-cols-2'>
    {/* 两列布局 */}
    <FormField
      control={form.control}
      name='field1'
      render={({ field }) => (
        <FormItem>
          <FormLabel>字段1</FormLabel>
          <FormControl>
            <Input type='number' {...field} />
          </FormControl>
          <FormDescription>字段说明（可选）</FormDescription>
          <FormMessage />
        </FormItem>
      )}
    />
    <FormField
      control={form.control}
      name='field2'
      render={({ field }) => (
        <FormItem>
          <FormLabel>字段2</FormLabel>
          <FormControl>
            <Input type='number' {...field} />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />
  </CardContent>
</Card>
```

### Switch 开关字段

```tsx
<FormField
  control={form.control}
  name='enabled'
  render={({ field }) => (
    <FormItem className='flex flex-row items-center justify-between rounded-lg border p-3'>
      <div className='space-y-0.5'>
        <FormLabel>启用功能</FormLabel>
        <FormDescription>功能说明文字</FormDescription>
      </div>
      <FormControl>
        <Switch checked={field.value} onCheckedChange={field.onChange} />
      </FormControl>
    </FormItem>
  )}
/>
```

---

## 确认弹窗规范

### 普通确认弹窗

```tsx
<ConfirmDialog
  open={open}
  onOpenChange={onOpenChange}
  handleConfirm={handleConfirm}
  title='确认操作'
  desc='确定要执行此操作吗？'
  confirmText='确认'
/>
```

### 危险操作确认弹窗（删除）

需要用户输入确认文本，防止误操作。

```tsx
import { AlertTriangle } from 'lucide-react'
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert'

<ConfirmDialog
  open={open}
  onOpenChange={onOpenChange}
  handleConfirm={handleDelete}
  disabled={inputValue.trim() !== expectedValue}
  title={
    <span className='text-destructive'>
      <AlertTriangle
        className='stroke-destructive me-1 inline-block'
        size={18}
      />
      删除项目
    </span>
  }
  desc={
    <div className='space-y-4'>
      <p className='mb-2'>
        确定要删除 <span className='font-bold'>{itemName}</span> 吗？
        <br />
        此操作无法恢复。
      </p>

      <Label className='my-2'>
        请输入名称确认：
        <Input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder='请输入名称以确认删除'
        />
      </Label>

      <Alert variant='destructive'>
        <AlertTitle>警告！</AlertTitle>
        <AlertDescription>
          请谨慎操作，此操作无法撤销。
        </AlertDescription>
      </Alert>
    </div>
  }
  confirmText='删除'
  destructive
/>
```

### ConfirmDialog Props

| 属性 | 类型 | 说明 |
|------|------|------|
| `open` | `boolean` | 弹窗开关状态 |
| `onOpenChange` | `(open: boolean) => void` | 状态变更回调 |
| `handleConfirm` | `() => void` | 确认按钮回调 |
| `title` | `React.ReactNode` | 标题（支持自定义样式） |
| `desc` | `React.JSX.Element \| string` | 描述内容 |
| `confirmText` | `React.ReactNode` | 确认按钮文本，默认 "确认" |
| `cancelBtnText` | `string` | 取消按钮文本，默认 "取消" |
| `destructive` | `boolean` | 是否为危险操作（红色按钮） |
| `disabled` | `boolean` | 是否禁用确认按钮 |
| `isLoading` | `boolean` | 是否加载中 |

---

## 表单验证

### Zod Schema 定义

```tsx
const formSchema = z
  .object({
    name: z.string().min(1, '请输入名称'),
    email: z.email({ error: (iss) => (iss.input === '' ? '请输入邮箱' : undefined) }),
    phone: z.string().min(1, '请输入电话'),
    role: z.string().min(1, '请选择角色'),
    password: z.string().transform((pwd) => pwd.trim()),
    confirmPassword: z.string().transform((pwd) => pwd.trim()),
    isEdit: z.boolean(),
  })
  // 条件验证：编辑时密码可选
  .refine(
    (data) => {
      if (data.isEdit && !data.password) return true
      return data.password.length > 0
    },
    { message: '请输入密码', path: ['password'] }
  )
  // 密码长度验证
  .refine(
    ({ isEdit, password }) => {
      if (isEdit && !password) return true
      return password.length >= 8
    },
    { message: '密码至少需要8个字符', path: ['password'] }
  )
  // 密码确认验证
  .refine(
    ({ isEdit, password, confirmPassword }) => {
      if (isEdit && !password) return true
      return password === confirmPassword
    },
    { message: '两次输入的密码不一致', path: ['confirmPassword'] }
  )

type FormValues = z.infer<typeof formSchema>
```

### useForm 配置

```tsx
const form = useForm<FormValues>({
  resolver: zodResolver(formSchema),
  defaultValues: isEdit
    ? {
        ...currentRow,
        password: '',
        confirmPassword: '',
        isEdit: true,
      }
    : {
        name: '',
        email: '',
        phone: '',
        role: '',
        password: '',
        confirmPassword: '',
        isEdit: false,
      },
})
```

### 提交处理

```tsx
const onSubmit = (values: FormValues) => {
  // 处理提交逻辑
  mutation.mutate(values)
  form.reset()
  onOpenChange(false)
}
```

---

## 输入组件

### 文本输入

```tsx
<FormControl>
  <Input
    placeholder='请输入...'
    className='col-span-4'
    autoComplete='off'
    {...field}
  />
</FormControl>
```

### 密码输入

```tsx
<FormControl>
  <PasswordInput
    placeholder='请输入密码'
    className='col-span-4'
    {...field}
  />
</FormControl>
```

### 多行文本

```tsx
<FormControl>
  <Textarea
    className='col-span-4 resize-none'
    placeholder='请输入描述...'
    {...field}
  />
</FormControl>
```

### 下拉选择

`SelectDropdown` 组件默认全宽（`w-full`），与其他表单元素保持一致。

```tsx
{/* 水平布局（Dialog 标准表单） */}
<SelectDropdown
  defaultValue={field.value}
  onValueChange={field.onChange}
  placeholder='请选择...'
  className='col-span-4'
  items={options.map(({ label, value }) => ({ label, value }))}
/>

{/* 垂直布局（Dialog 简单表单、Sheet、Card 内） */}
<SelectDropdown
  defaultValue={field.value}
  onValueChange={field.onChange}
  placeholder='请选择...'
  items={options.map(({ label, value }) => ({ label, value }))}
/>
```

### 条件禁用

```tsx
const isPasswordTouched = !!form.formState.dirtyFields.password

<FormControl>
  <PasswordInput
    disabled={!isPasswordTouched}
    placeholder='请再次输入密码'
    className='col-span-4'
    {...field}
  />
</FormControl>
```

---

## 交互体验增强

### "脏表单"关闭拦截 (Dirty Form Guard)

用户在填写了长表单但未保存时，如果不小心点击了遮罩层关闭弹窗，数据丢失会非常令人沮丧。

**强制规范**：在 `onOpenChange` 中增加拦截逻辑，检查表单是否有未保存的修改。

```tsx
// 弹窗组件内部
const onOpenChangeWrapper = (open: boolean) => {
  // 如果正在关闭且表单有修改
  if (!open && form.formState.isDirty) {
    // 方式1：使用 window.confirm（简单但不美观）
    if (!window.confirm('您有未保存的修改，确定要关闭吗？')) {
      return
    }
  }
  onOpenChange(open)
}

// 使用
<Dialog open={open} onOpenChange={onOpenChangeWrapper}>
```

**推荐方式**：使用 `ConfirmDialog` 组件进行拦截，体验更好：

```tsx
const [confirmCloseOpen, setConfirmCloseOpen] = useState(false)

const onOpenChangeWrapper = (open: boolean) => {
  if (!open && form.formState.isDirty) {
    setConfirmCloseOpen(true)
    return
  }
  onOpenChange(open)
}

return (
  <>
    <Dialog open={open} onOpenChange={onOpenChangeWrapper}>
      {/* 弹窗内容 */}
    </Dialog>

    <ConfirmDialog
      open={confirmCloseOpen}
      onOpenChange={setConfirmCloseOpen}
      handleConfirm={() => {
        setConfirmCloseOpen(false)
        onOpenChange(false)
      }}
      title='放弃修改？'
      desc='您有未保存的修改，确定要关闭吗？'
      confirmText='放弃'
      destructive
    />
  </>
)
```

### 嵌套弹窗层级 (Stacked Dialogs)

在 `Dialog` 中唤起 `ConfirmDialog`（例如编辑时点击删除）时，需要注意以下问题：

**潜在问题**：两层遮罩叠加会导致背景变得非常黑（Double Overlay）。

**解决方案**：

1. **使用 AlertDialog**：`ConfirmDialog` 底层应使用 `AlertDialog` 原语（层级更高），而非普通 `Dialog`
2. **样式处理**：如果必须使用 `Dialog`，可以通过 CSS 降低内层遮罩透明度

```tsx
// ConfirmDialog 应该基于 AlertDialog 实现
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'
```

### 详情抽屉中的"快捷编辑"

虽然已规定"查看与编辑分离"，但用户在查看详情时，往往会发现一个小错误想立刻改。

**强制规范**：在 `Sheet` (查看详情) 的 Footer，除了"关闭"按钮，**必须保留一个"去编辑"按钮**。

```tsx
<SheetFooter>
  <Button variant='outline' onClick={() => setViewOpen(false)}>
    关闭
  </Button>
  <Button onClick={() => { 
    setViewOpen(false)  // 先关闭详情抽屉
    onEdit(item)        // 再打开编辑弹窗
  }}>
    编辑
  </Button>
</SheetFooter>
```

---

## 数据加载与错误处理

### 数据加载状态 (Loading Skeleton)

如果是点击编辑才请求详情接口（而不是直接传 row 数据），需要显示骨架屏。

```tsx
import { Skeleton } from '@/components/ui/skeleton'

// 在弹窗内容区域
{isLoading ? (
  <div className='space-y-4 p-4'>
    <Skeleton className='h-4 w-full' />
    <Skeleton className='h-10 w-full' />
    <Skeleton className='h-4 w-3/4' />
    <Skeleton className='h-10 w-full' />
    <Skeleton className='h-4 w-1/2' />
    <Skeleton className='h-10 w-full' />
  </div>
) : (
  <Form {...form}>
    {/* 表单内容 */}
  </Form>
)}
```

### 错误处理回显规范

错误分为两类，处理方式不同：

| 错误类型 | 显示方式 | 说明 |
|---------|---------|------|
| **字段级验证错误** | `FormMessage` | Zod 验证失败，显示在对应字段下方 |
| **API 级错误** | `toast.error()` | 服务端返回的错误（如"名称重复"） |

```tsx
// API 错误使用 Toast 显示
const createMutation = useMutation({
  mutationFn: (payload: any) => api.create(payload),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['items'] })
    onOpenChange(false)
    toast.success('创建成功')
  },
  onError: (error: Error) => {
    // API 错误统一用 Toast
    toast.error(error.message || '创建失败')
  },
})
```

**特殊情况**：如果需要错误信息常驻（例如重要警告），可以在表单顶部显示 Alert：

```tsx
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert'
import { AlertCircle } from 'lucide-react'

{apiError && (
  <Alert variant='destructive' className='mb-4'>
    <AlertCircle className='h-4 w-4' />
    <AlertTitle>操作失败</AlertTitle>
    <AlertDescription>{apiError}</AlertDescription>
  </Alert>
)}
```

### URL 状态同步 (Deep Linking) - 进阶

对于复杂的配置抽屉（Sheet），用户可能需要分享链接给同事："你帮我看看这个配置"。

**适用场景**：
- 详情页抽屉
- 复杂配置页面
- 需要支持浏览器前进/后退

**实现方式**：使用 URL Query 参数同步弹窗状态。

```tsx
import { useSearchParams } from 'react-router-dom'

function PageWithDrawer() {
  const [searchParams, setSearchParams] = useSearchParams()
  
  // 从 URL 读取状态
  const drawerId = searchParams.get('drawer')
  const itemId = searchParams.get('id')
  
  const handleOpenDetail = (id: string) => {
    setSearchParams({ drawer: 'detail', id })
  }
  
  const handleClose = () => {
    setSearchParams({})
  }
  
  return (
    <>
      {/* 列表 */}
      <DataTable onRowClick={(row) => handleOpenDetail(row.id)} />
      
      {/* 抽屉：根据 URL 参数控制 */}
      <Sheet 
        open={drawerId === 'detail' && !!itemId} 
        onOpenChange={(open) => !open && handleClose()}
      >
        <DetailContent itemId={itemId} />
      </Sheet>
    </>
  )
}
```

> 📝 **注意**：此为进阶功能，一般业务弹窗不需要实现，仅在确有分享/书签需求时使用。

---

## 响应式与移动端适配

### Dialog 移动端表现

`Dialog` 在移动端默认居中显示，宽度会自动适应屏幕。

```tsx
// sm:max-w-lg 表示：
// - 移动端：宽度接近全屏（有少量边距）
// - 桌面端：最大宽度 512px
<DialogContent className='sm:max-w-lg'>
```

### Sheet 移动端适配

**强制规范**：`Sheet` 在不同设备上应该从不同方向弹出。

| 设备 | 弹出方向 | 原因 |
|------|---------|------|
| 桌面端 | 右侧 (right) | 不遮挡主内容，可参考 |
| 移动端 | 底部 (bottom) | 拇指操作友好 |

**实现方式**：

```tsx
import { useMediaQuery } from '@/hooks/use-media-query'

function ResponsiveSheet({ open, onOpenChange, children }) {
  const isMobile = useMediaQuery('(max-width: 768px)')
  
  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent 
        side={isMobile ? 'bottom' : 'right'}
        className={isMobile ? 'h-[85vh]' : 'w-[500px] sm:max-w-[500px]'}
      >
        {children}
      </SheetContent>
    </Sheet>
  )
}
```

**useMediaQuery Hook**：

```tsx
// src/hooks/use-media-query.ts
import { useState, useEffect } from 'react'

export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(false)

  useEffect(() => {
    const media = window.matchMedia(query)
    if (media.matches !== matches) {
      setMatches(media.matches)
    }
    const listener = () => setMatches(media.matches)
    media.addEventListener('change', listener)
    return () => media.removeEventListener('change', listener)
  }, [matches, query])

  return matches
}
```

---

## 弹窗文件分离规范

### 核心原则：彻底的封装

分离不仅仅是把 JSX 搬运到另一个文件，而是要实现**逻辑的内聚**。

| 原则 | 说明 |
|------|------|
| **Schema 内聚** | Zod 定义 (`formSchema`) 必须放在子文件内，父组件不需要知道表单的验证规则 |
| **逻辑内聚** | `useForm`、提交逻辑 (`onSubmit`)、API 调用均封装在子文件内 |
| **接口精简** | 父组件只负责控制"开关"和"传递初始数据"，子组件只负责"处理业务"和"通知结果" |

### 文件目录结构

采用 **Feature-based** 结构，将弹窗组件归档在当前业务模块的 `components` 目录下。

```text
src/features/{module}/              # 业务模块
├── index.tsx                       # 主页面（列表页）
└── components/                     # 模块独享组件
    ├── {module}-action-dialog.tsx  # [核心] 新建/编辑弹窗
    ├── {module}-delete-dialog.tsx  # [核心] 删除确认弹窗
    ├── {module}-detail-sheet.tsx   # [可选] 详情抽屉
    ├── {module}-invite-dialog.tsx  # [可选] 邀请弹窗
    └── {module}-dialogs.tsx        # [可选] 弹窗聚合入口
```

### 子文件代码模板 (The Child)

这是分离后的标准弹窗组件结构：

```tsx
// src/features/{module}/components/{module}-action-dialog.tsx

import { useEffect } from 'react'
import { z } from 'zod'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { toast } from 'sonner'
import { Loader2 } from 'lucide-react'
// ... 其他 import

// 1. Zod Schema 定义在文件内部，不暴露给外部
const formSchema = z.object({
  name: z.string().min(1, '请输入名称'),
  // ... 其他字段
})

type FormValues = z.infer<typeof formSchema>

// 2. 定义清晰的 Props 接口
interface ModuleActionDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  currentRow?: ItemType     // 如果有值则是编辑模式，否则是新建
  onSuccess?: () => void    // 成功后的回调（通常用于刷新列表）
}

export function ModuleActionDialog({
  open,
  onOpenChange,
  currentRow,
  onSuccess,
}: ModuleActionDialogProps) {
  const isEdit = !!currentRow
  const queryClient = useQueryClient()

  // 表单逻辑完全封闭在组件内
  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      // ... 其他默认值
    },
  })

  // 监听 open 变化以重置/回填表单
  useEffect(() => {
    if (open && currentRow) {
      form.reset({
        name: currentRow.name,
        // ... 其他字段
      })
    } else if (open) {
      form.reset({
        name: '',
        // ... 其他默认值
      })
    }
  }, [open, currentRow, form])

  // API 调用
  const createMutation = useMutation({
    mutationFn: (payload: any) => api.create(payload),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['items'] })
      onOpenChange(false)
      toast.success('创建成功')
      onSuccess?.() // 通知父组件
    },
    onError: (error: Error) => {
      toast.error(error.message || '创建失败')
    },
  })

  const updateMutation = useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: any }) =>
      api.update(id, payload),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['items'] })
      onOpenChange(false)
      toast.success('更新成功')
      onSuccess?.() // 通知父组件
    },
    onError: (error: Error) => {
      toast.error(error.message || '更新失败')
    },
  })

  const onSubmit = (values: FormValues) => {
    if (isEdit && currentRow) {
      updateMutation.mutate({ id: currentRow.id, payload: values })
    } else {
      createMutation.mutate(values)
    }
  }

  const isPending = createMutation.isPending || updateMutation.isPending

  return (
    <Dialog
      open={open}
      onOpenChange={(state) => {
        if (!isPending) {
          onOpenChange(state)
        }
      }}
    >
      <DialogContent className='sm:max-w-lg'>
        {/* 完整的 Dialog 内容 */}
      </DialogContent>
    </Dialog>
  )
}
```

### 主文件调用方式 (The Parent)

主文件（`index.tsx`）现在变得非常清爽：

```tsx
// src/features/{module}/index.tsx

import { useState } from 'react'
import { useQuery } from '@tanstack/react-query'
import { ModuleActionDialog } from './components/module-action-dialog'
import { ModuleDeleteDialog } from './components/module-delete-dialog'

export default function ModulePage() {
  // 弹窗状态
  const [actionOpen, setActionOpen] = useState(false)
  const [deleteOpen, setDeleteOpen] = useState(false)
  const [currentRow, setCurrentRow] = useState<ItemType | null>(null)

  // 列表数据
  const { data, refetch } = useQuery({
    queryKey: ['items'],
    queryFn: () => api.getList(),
  })

  const handleCreate = () => {
    setCurrentRow(null)
    setActionOpen(true)
  }

  const handleEdit = (row: ItemType) => {
    setCurrentRow(row)
    setActionOpen(true)
  }

  const handleDelete = (row: ItemType) => {
    setCurrentRow(row)
    setDeleteOpen(true)
  }

  return (
    <>
      {/* 页面主内容：只负责布局和表格 */}
      <DataTable
        data={data}
        onEdit={handleEdit}
        onDelete={handleDelete}
      />
      <Button onClick={handleCreate}>新建</Button>

      {/* 弹窗区域：代码极度简洁 */}
      <ModuleActionDialog
        key={currentRow ? `edit-${currentRow.id}` : 'create'}
        open={actionOpen}
        onOpenChange={(open) => {
          setActionOpen(open)
          if (!open) {
            setTimeout(() => setCurrentRow(null), 300)
          }
        }}
        currentRow={currentRow ?? undefined}
        onSuccess={refetch}
      />

      <ModuleDeleteDialog
        open={deleteOpen}
        onOpenChange={setDeleteOpen}
        currentRow={currentRow}
        onSuccess={refetch}
      />
    </>
  )
}
```

### 进阶优化：性能提升 (Lazy Loading)

既然文件已经分离，可以利用动态导入特性。

**为什么需要？**  
富文本编辑器、复杂的配置表单往往体积很大。如果用户只是进来看看列表，没必要加载这些沉重的 JS 代码。

```tsx
// src/features/{module}/index.tsx

import dynamic from 'next/dynamic'

// 动态导入，不占用首屏加载体积
const ModuleActionDialog = dynamic(
  () => import('./components/module-action-dialog').then((mod) => mod.ModuleActionDialog),
  {
    loading: () => null,  // 或者返回一个 Skeleton
    ssr: false            // 弹窗通常不需要服务端渲染
  }
)

export default function ModulePage() {
  // ... 逻辑不变
}
```

### 分离的好处

| 好处 | 说明 |
|------|------|
| **代码行数骤减** | 主页面逻辑聚焦于列表展示和状态分发，通常能控制在 200 行以内 |
| **Git 冲突减少** | 多人开发时，一个人改列表，一个人改表单，互不干扰 |
| **复用性增强** | 如果其他页面也需要用到同样的弹窗，可以直接引入 |
| **按需加载** | 天然支持 Code Splitting，优化首屏性能 |

---

## 文件结构

> 📌 **详细规范请参阅上方 [弹窗文件分离规范](#弹窗文件分离规范) 章节**

### 快速参考

```text
src/features/{module}/              # 业务模块
├── index.tsx                       # 主页面（列表页）
└── components/                     # 模块独享组件
    ├── {module}-action-dialog.tsx  # [必须] 新建/编辑弹窗
    ├── {module}-delete-dialog.tsx  # [必须] 删除确认弹窗
    ├── {module}-detail-sheet.tsx   # [可选] 详情抽屉
    └── {module}-dialogs.tsx        # [可选] 弹窗聚合入口
```

### 状态管理 Provider（可选进阶）

当弹窗状态需要在多个组件间共享时，可以使用 Context Provider：

```tsx
// {module}-provider.tsx
import { createContext, useContext, useState } from 'react'

type DialogType = 'add' | 'edit' | 'delete' | 'detail' | null

type ModuleContextType = {
  open: DialogType
  setOpen: (type: DialogType) => void
  currentRow: ItemType | null
  setCurrentRow: (row: ItemType | null) => void
}

const ModuleContext = createContext<ModuleContextType | null>(null)

export function ModuleProvider({ children }: { children: React.ReactNode }) {
  const [open, setOpen] = useState<DialogType>(null)
  const [currentRow, setCurrentRow] = useState<ItemType | null>(null)

  return (
    <ModuleContext.Provider value={{ open, setOpen, currentRow, setCurrentRow }}>
      {children}
    </ModuleContext.Provider>
  )
}

export function useModule() {
  const context = useContext(ModuleContext)
  if (!context) throw new Error('useModule must be used within ModuleProvider')
  return context
}
```

> 💡 **提示**：对于简单场景，直接在主页面使用 `useState` 管理弹窗状态即可，不需要 Provider。

---

## 完整示例

参考以下文件作为完整实现示例：

### Dialog 弹窗示例

- **员工新建/编辑弹窗**（标准表单 Dialog）
  - `src/features/hr/components/employees-action-dialog.tsx`

- **员工邀请弹窗**（简单表单 Dialog）
  - `src/features/hr/components/employees-invite-dialog.tsx`

- **员工删除弹窗**（确认弹窗）
  - `src/features/hr/components/employees-delete-dialog.tsx`

### Sheet 抽屉示例

- **主题配置抽屉**（配置类 Sheet）
  - `src/components/config-drawer.tsx`

### 多板块弹窗示例

- **分销配置弹窗**（Tabs + Dialog）
  - `src/features/distribution/components/config-dialog.tsx`

### 状态管理示例

- **弹窗聚合**
  - `src/features/hr/components/employees-dialogs.tsx`

- **状态管理 Provider**
  - `src/features/hr/components/employees-provider.tsx`

---

## 常见问题与反模式

### Do's and Don'ts

| ✅ 推荐做法 | ❌ 避免做法 |
|:---|:---|
| 使用 **Tabs 分组**长表单 | 在一个长页面中无限滚动查找字段 |
| 关闭前检查 **isDirty** | 用户误触关闭导致辛苦填写的数据丢失 |
| 使用 **vh** 控制滚动高度 | 使用固定 **px** 导致小屏显示不全 |
| 详情页提供 **"去编辑"** 入口 | 详情页强行塞入 Input 变为"混合模式" |
| 弹窗组件**独立文件**封装 | 所有逻辑挤在主页面，单文件 1000+ 行 |
| API 错误用 **Toast** 提示 | 错误信息无处展示，用户一脸懵 |
| 加载时显示 **Skeleton** | 空白等待，用户以为卡住了 |
| 移动端 Sheet 从**底部**弹出 | 强制侧边弹出，拇指够不到 |
| 使用 **SelectDropdown** 组件 | 原生 select 样式不统一 |
| 使用 **ConfirmDialog** 确认 | `window.confirm` 丑陋且无法自定义 |

### 常见 Bug 避免

#### 1. 编辑弹窗数据没有回填

```tsx
// ❌ 错误：defaultValues 只在组件挂载时生效
const form = useForm({
  defaultValues: currentRow || { name: '' }
})

// ✅ 正确：使用 useEffect 监听 currentRow 变化
useEffect(() => {
  if (open && currentRow) {
    form.reset(currentRow)
  }
}, [open, currentRow, form])
```

#### 2. 关闭弹窗后再打开，显示上次数据

```tsx
// ❌ 错误：没有在关闭时重置
<Dialog open={open} onOpenChange={setOpen}>

// ✅ 正确：关闭时重置表单
<Dialog 
  open={open} 
  onOpenChange={(state) => {
    if (!state) form.reset()
    setOpen(state)
  }}
>
```

#### 3. 提交时弹窗被意外关闭

```tsx
// ❌ 错误：提交过程中可以关闭弹窗
<Dialog open={open} onOpenChange={setOpen}>

// ✅ 正确：提交过程中禁止关闭
<Dialog 
  open={open} 
  onOpenChange={(state) => {
    if (!isPending) {
      setOpen(state)
    }
  }}
>
```

#### 4. Switch 组件表单提交问题

```tsx
// ❌ 错误：直接使用 FormData，Switch 不会正确提交
const formData = new FormData(e.currentTarget)
const isActive = formData.get('isActive') // 可能是 null 或 'on'

// ✅ 正确：使用 react-hook-form 管理 Switch 状态
<FormField
  control={form.control}
  name='isActive'
  render={({ field }) => (
    <Switch checked={field.value} onCheckedChange={field.onChange} />
  )}
/>
```

#### 5. 嵌套弹窗焦点问题

```tsx
// ❌ 错误：DropdownMenu 在 Dialog 中不能正常工作
<Dialog>
  <DropdownMenu>...</DropdownMenu>
</Dialog>

// ✅ 正确：给 DropdownMenu 添加 modal={false}
<Dialog>
  <DropdownMenu modal={false}>...</DropdownMenu>
</Dialog>
```

#### 6. Focus Ring 被裁切

```tsx
// ❌ 错误：只有右侧 padding，左侧 focus ring 被 overflow 裁切
<div className='overflow-y-auto pe-2'>
  <Input /> {/* 聚焦时左侧描边被裁切 */}
</div>

// ✅ 正确：左右都有 padding，给 focus ring 留出空间
<div className='overflow-y-auto px-1'>
  <Input /> {/* 聚焦时描边完整显示 */}
</div>
```

> ⚠️ **重要**：任何带有 `overflow-y-auto` 或 `overflow-hidden` 的容器，如果内部有可聚焦元素（Input、Select 等），都需要添加 `px-1` 或更大的水平 padding，否则 focus ring 会被裁切。

---

## 检查清单

开发新弹窗时，请确认以下要点：

### 类型选择

- [ ] 根据决策流程选择正确的弹窗类型（Dialog / Sheet）
- [ ] 字段 > 15 个或多板块时使用 Sheet + Tabs
- [ ] 配置/设置类使用 Sheet
- [ ] 确认操作使用 ConfirmDialog
- [ ] 详情查看使用 Sheet，不与编辑混用

### 文件组织

- [ ] 弹窗组件独立文件，不与主页面混写
- [ ] Schema 定义在弹窗组件内部
- [ ] API 调用封装在弹窗组件内部
- [ ] Props 接口清晰：`open`、`onOpenChange`、`currentRow`、`onSuccess`

### 表单规范

- [ ] 使用 `react-hook-form` + `zod` 进行表单管理和验证
- [ ] 使用 `Form` 系列组件（FormField, FormItem, FormLabel, FormControl, FormMessage）
- [ ] Dialog 标准表单使用水平布局 `grid grid-cols-6`
- [ ] Dialog 简单表单使用垂直布局 `space-y-4`
- [ ] Sheet/多板块表单使用 Card + Grid 布局
- [ ] 使用 `max-h-[60vh] min-h-[300px]` 响应式高度

### 交互规范

- [ ] 弹窗关闭时调用 `form.reset()` 重置表单
- [ ] 使用 form id 关联 Footer 中的提交按钮
- [ ] 删除操作使用 `ConfirmDialog` + `destructive` 样式
- [ ] 危险操作需要输入确认文本
- [ ] 多板块使用 Tabs 组织，每个 Tab 内用 Card 分组
- [ ] 表单有修改时，关闭前显示确认提示
- [ ] 详情抽屉 Footer 包含"去编辑"按钮

### 状态与错误处理

- [ ] 提交过程中禁止关闭弹窗
- [ ] 提交按钮显示 loading 状态
- [ ] API 错误使用 `toast.error()` 提示
- [ ] 编辑模式使用 `useEffect` 回填数据
- [ ] 加载数据时显示 Skeleton

### 组件规范

- [ ] 下拉选择使用 `SelectDropdown` 组件
- [ ] 密码输入使用 `PasswordInput` 组件
- [ ] 开关选项使用 `Switch` 组件
- [ ] 长内容区域添加 `overflow-y-auto`
- [ ] DropdownMenu 在弹窗内使用时添加 `modal={false}`

### 响应式

- [ ] Dialog 宽度使用 `sm:max-w-lg` 等响应式类
- [ ] Sheet 在移动端考虑从底部弹出
