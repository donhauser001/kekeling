# 交互体验增强

## "脏表单"关闭拦截 (Dirty Form Guard)

用户在填写了长表单但未保存时，如果不小心点击了遮罩层关闭弹窗，数据丢失会非常令人沮丧。

**强制规范**：在 `onOpenChange` 中增加拦截逻辑，检查表单是否有未保存的修改。

### 简单方式（使用 window.confirm）

```tsx
const onOpenChangeWrapper = (open: boolean) => {
  // 如果正在关闭且表单有修改
  if (!open && form.formState.isDirty) {
    if (!window.confirm('您有未保存的修改，确定要关闭吗？')) {
      return
    }
  }
  onOpenChange(open)
}

// 使用
<Dialog open={open} onOpenChange={onOpenChangeWrapper}>
```

### 推荐方式（使用 ConfirmDialog）

```tsx
const [confirmCloseOpen, setConfirmCloseOpen] = useState(false)

const onOpenChangeWrapper = (open: boolean) => {
  if (!open && form.formState.isDirty) {
    setConfirmCloseOpen(true)
    return
  }
  onOpenChange(open)
}

return (
  <>
    <Dialog open={open} onOpenChange={onOpenChangeWrapper}>
      {/* 弹窗内容 */}
    </Dialog>

    <ConfirmDialog
      open={confirmCloseOpen}
      onOpenChange={setConfirmCloseOpen}
      handleConfirm={() => {
        setConfirmCloseOpen(false)
        onOpenChange(false)
      }}
      title='放弃修改？'
      desc='您有未保存的修改，确定要关闭吗？'
      confirmText='放弃'
      destructive
    />
  </>
)
```

---

## 嵌套弹窗层级 (Stacked Dialogs)

在 `Dialog` 中唤起 `ConfirmDialog`（例如编辑时点击删除）时，需要注意以下问题：

**潜在问题**：两层遮罩叠加会导致背景变得非常黑（Double Overlay）。

**解决方案**：

1. **使用 AlertDialog**：`ConfirmDialog` 底层应使用 `AlertDialog` 原语（层级更高），而非普通 `Dialog`
2. **样式处理**：如果必须使用 `Dialog`，可以通过 CSS 降低内层遮罩透明度

```tsx
// ConfirmDialog 应该基于 AlertDialog 实现
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'
```

---

## 详情抽屉中的"快捷编辑"

虽然已规定"查看与编辑分离"，但用户在查看详情时，往往会发现一个小错误想立刻改。

**强制规范**：在 `Sheet` (查看详情) 的 Footer，除了"关闭"按钮，**必须保留一个"去编辑"按钮**。

```tsx
<SheetFooter>
  <Button variant='outline' onClick={() => setViewOpen(false)}>
    关闭
  </Button>
  <Button onClick={() => { 
    setViewOpen(false)  // 先关闭详情抽屉
    onEdit(item)        // 再打开编辑弹窗
  }}>
    编辑
  </Button>
</SheetFooter>
```

---

## 提交过程禁止关闭

防止用户在提交过程中意外关闭弹窗：

```tsx
const isPending = createMutation.isPending || updateMutation.isPending

<Dialog 
  open={open} 
  onOpenChange={(state) => {
    if (!isPending) {
      onOpenChange(state)
    }
  }}
>
```

---

## 提交按钮 Loading 状态

```tsx
<Button type='submit' form='entity-form' disabled={isPending}>
  {isPending && <Loader2 className='mr-2 h-4 w-4 animate-spin' />}
  {isEdit ? '更新' : '创建'}
</Button>
```

---

## 取消按钮行为

取消按钮应该触发脏表单拦截逻辑：

```tsx
<Button 
  type='button' 
  variant='outline' 
  onClick={() => onOpenChangeWrapper(false)} 
  disabled={isPending}
>
  取消
</Button>
```
