# 双视图切换

本文档定义了列表页支持「卡片网格视图」和「列表视图」双视图切换的开发规范。

---

## 适用场景

| 视图模式 | 适用场景 |
|---------|---------|
| **仅列表** | 数据密集、字段多、需要排序筛选（如订单、用户） |
| **仅卡片** | 图片为主、信息少（如相册、Banner） |
| **双视图** | 商品、服务、内容管理等需要多角度浏览的场景 |

---

## 文件结构

```
src/features/{module}/
├── index.tsx                      # 主页面（视图切换逻辑）
└── components/
    ├── {module}-columns.tsx       # 列表视图列定义
    ├── {module}-table.tsx         # 列表视图组件
    ├── {module}-grid.tsx          # 卡片网格视图组件（可选，也可内联）
    ├── {module}-card.tsx          # 单个卡片组件（可选，也可内联）
    ├── {module}-action-dialog.tsx # 新建/编辑弹窗
    ├── {module}-detail-sheet.tsx  # 查看详情抽屉
    └── index.ts                   # 导出文件
```

---

## 核心依赖

> ⚠️ **强制要求**：双视图页面必须使用 `useReactTable` 管理表格状态，即使卡片视图不直接使用表格。

```tsx
import { useMemo, useState, useEffect } from 'react'
import { useNavigate, useSearch } from '@tanstack/react-router'
import {
  useReactTable,
  getCoreRowModel,
  getFilteredRowModel,
  type ColumnFiltersState,
} from '@tanstack/react-table'
import { DataTableToolbar, DataTablePagination, DataTableViewOptions } from '@/components/data-table'
```

**为什么需要 `useReactTable`？**

1. `DataTableToolbar` 依赖 `table` 实例进行筛选
2. `DataTablePagination` 依赖 `table` 实例进行分页
3. `DataTableViewOptions` 依赖 `table` 实例控制列显隐
4. 保持两种视图的筛选/分页状态同步

---

## 视图状态持久化

> ⚠️ **强制要求**：视图状态必须持久化到 URL 参数，刷新页面后保持原视图状态。

### 使用 useSearch 持久化

```tsx
import { useNavigate, useSearch } from '@tanstack/react-router'

type ViewMode = 'grid' | 'list'

export function Services() {
  const navigate = useNavigate()
  const searchParams = useSearch({ strict: false }) as { view?: string }

  // 从 URL 读取视图状态，默认为 'grid'
  const initialViewMode = (searchParams.view === 'list' ? 'list' : 'grid') as ViewMode
  const [viewMode, setViewMode] = useState<ViewMode>(initialViewMode)

  // 同步视图模式到 URL
  useEffect(() => {
    const currentView = searchParams.view
    if (viewMode !== (currentView === 'list' ? 'list' : 'grid')) {
      navigate({
        search: (prev: Record<string, unknown>) => ({
          ...prev,
          view: viewMode === 'list' ? 'list' : undefined,  // grid 为默认值，不写入 URL
        }),
        replace: true,  // 不产生历史记录
      })
    }
  }, [viewMode, navigate, searchParams.view])

  // ...
}
```

### 路由配置（可选）

```tsx
// routes/_authenticated/services/index.tsx
export const Route = createFileRoute('/_authenticated/services/')({
  validateSearch: (search: Record<string, unknown>) => ({
    view: (search.view as 'grid' | 'list') || 'grid',
    page: Number(search.page) || 1,
    pageSize: Number(search.pageSize) || 12,
    // ...其他筛选参数
  }),
})
```

---

## 页面布局规范

> ⚠️ **强制要求**：`Main` 组件必须使用 `flex flex-1 flex-col gap-4 sm:gap-6` 布局。

```tsx
<Main className='flex flex-1 flex-col gap-4 sm:gap-6'>
  {/* 标题区 */}
  <div className='flex flex-wrap items-end justify-between gap-2'>
    <div>
      <h2 className='text-2xl font-bold tracking-tight'>服务管理</h2>
      <p className='text-muted-foreground'>管理服务项目</p>
    </div>
    <Button onClick={handleCreate}>
      <Plus className='mr-2 h-4 w-4' />
      新建
    </Button>
  </div>

  {/* 工具栏 */}
  <div className='flex flex-wrap items-center gap-4'>
    ...
  </div>

  {/* 内容区（表格或卡片） */}
  {viewMode === 'grid' ? renderGridView() : <ServicesTable ... />}

  {/* 分页（固定底部） */}
  <DataTablePagination table={table} className='mt-auto' />
</Main>
```

**布局要点：**

| 属性 | 作用 |
|------|------|
| `flex flex-1 flex-col` | Main 撑满剩余高度，内部垂直布局 |
| `gap-4 sm:gap-6` | 统一组件间距，不需要额外 `mb-*` |
| `mt-auto` | 翻页组件固定在底部 |

---

## 工具栏规范

> ⚠️ **强制要求**：必须使用 `DataTableToolbar`，不要自定义筛选实现。

### 标准布局

```tsx
import { DataTableToolbar, DataTableViewOptions } from '@/components/data-table'

{/* 工具栏 */}
<div className='flex flex-wrap items-center gap-4'>
  {/* 左侧：搜索 + 筛选器 */}
  <DataTableToolbar
    table={table}
    searchPlaceholder='搜索服务名称...'
    showViewOptions={false}  // 禁用内置的显示列，单独放置
    filters={[
      {
        columnId: 'categoryId',
        title: '分类',
        options: categoryOptions,
      },
      {
        columnId: 'status',
        title: '状态',
        options: [
          { label: '已上架', value: 'active' },
          { label: '已下架', value: 'inactive' },
          { label: '草稿', value: 'draft' },
        ],
      },
    ]}
  />

  {/* 右侧：显示列 + 视图切换器 */}
  <div className='ms-auto flex items-center gap-2'>
    <DataTableViewOptions table={table} />
    <Tabs value={viewMode} onValueChange={v => setViewMode(v as ViewMode)}>
      <TabsList className='h-9'>
        <TabsTrigger value='grid' className='px-2.5' aria-label='网格视图'>
          <LayoutGrid className='h-4 w-4' />
        </TabsTrigger>
        <TabsTrigger value='list' className='px-2.5' aria-label='列表视图'>
          <List className='h-4 w-4' />
        </TabsTrigger>
      </TabsList>
    </Tabs>
  </div>
</div>
```

### 工具栏布局说明

| 位置 | 组件 | 说明 |
|------|------|------|
| 左侧 | `DataTableToolbar` | 搜索框 + 筛选器 + 重置按钮 |
| 右侧 | `DataTableViewOptions` | 显示列控制 |
| 最右 | `Tabs` | 视图切换器 |

> 注意：`showViewOptions={false}` 禁用 `DataTableToolbar` 内置的显示列按钮，然后单独添加 `DataTableViewOptions` 放在视图切换器左侧。

---

## useReactTable 配置

```tsx
// 筛选状态
const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([])
const [globalFilter, setGlobalFilter] = useState('')

// 从列筛选中提取 API 参数（服务端筛选）
const categoryFilter = columnFilters.find(f => f.id === 'categoryId')?.value as string[] | undefined
const statusFilter = columnFilters.find(f => f.id === 'status')?.value as string[] | undefined

// API 查询
const { data, isLoading } = useServices({
  categoryId: categoryFilter?.length === 1 ? categoryFilter[0] : undefined,
  keyword: globalFilter || undefined,
  status: statusFilter?.length === 1 ? statusFilter[0] : undefined,
  page,
  pageSize,
})

// 列定义
const columns = useMemo(
  () => getColumns({
    onView: handleView,
    onEdit: handleEdit,
    onDelete: handleDelete,
    // ...其他回调
  }),
  [/* dependencies */]
)

// 表格实例
const table = useReactTable({
  data: services,
  columns,
  state: {
    columnFilters,
    globalFilter,
    pagination: { pageIndex: page - 1, pageSize },
  },
  pageCount: Math.ceil(total / pageSize),
  onColumnFiltersChange: setColumnFilters,
  onGlobalFilterChange: setGlobalFilter,
  onPaginationChange: (updater) => {
    const newState = typeof updater === 'function'
      ? updater({ pageIndex: page - 1, pageSize })
      : updater
    setPage(newState.pageIndex + 1)
    setPageSize(newState.pageSize)
  },
  getCoreRowModel: getCoreRowModel(),
  getFilteredRowModel: getFilteredRowModel(),
  manualPagination: true,   // 服务端分页
  manualFiltering: true,    // 服务端筛选
})
```

---

## 操作菜单规范

> ⚠️ **强制要求**：两种视图的操作菜单必须完全一致。

### 标准操作菜单

```tsx
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'

<DropdownMenu modal={false}>
  <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>
    <Button
      variant='ghost'
      size='icon'
      className='h-8 w-8 opacity-0 group-hover:opacity-100'
    >
      <MoreHorizontal className='h-4 w-4' />
    </Button>
  </DropdownMenuTrigger>
  <DropdownMenuContent align='end' className='w-[160px]'>
    <DropdownMenuItem onClick={(e) => { e.stopPropagation(); onView(item) }}>
      查看详情
      <DropdownMenuShortcut><Eye className='h-4 w-4' /></DropdownMenuShortcut>
    </DropdownMenuItem>
    <DropdownMenuItem onClick={(e) => { e.stopPropagation(); onEdit(item) }}>
      编辑
      <DropdownMenuShortcut><Pencil className='h-4 w-4' /></DropdownMenuShortcut>
    </DropdownMenuItem>
    {/* 业务操作（如上架/下架） */}
    <DropdownMenuItem onClick={(e) => { e.stopPropagation(); onToggleStatus(item) }}>
      {item.status === 'active' ? '下架' : '上架'}
      <DropdownMenuShortcut>
        {item.status === 'active' ? (
          <ArrowDownCircle className='h-4 w-4' />
        ) : (
          <ArrowUpCircle className='h-4 w-4' />
        )}
      </DropdownMenuShortcut>
    </DropdownMenuItem>
    <DropdownMenuSeparator />
    <DropdownMenuItem
      onClick={(e) => { e.stopPropagation(); onDelete(item) }}
      className='text-destructive focus:text-destructive focus:bg-destructive/10'
    >
      删除
      <DropdownMenuShortcut><Trash2 className='h-4 w-4' /></DropdownMenuShortcut>
    </DropdownMenuItem>
  </DropdownMenuContent>
</DropdownMenu>
```

### 操作菜单规范要点

| 属性/行为 | 规范 | 说明 |
|----------|------|------|
| `modal={false}` | **必须** | 避免弹窗层级问题 |
| `onClick={(e) => e.stopPropagation()}` | **必须** | Trigger 和每个 MenuItem 都要阻止冒泡 |
| `className='w-[160px]'` | **必须** | 统一菜单宽度 |
| `DropdownMenuShortcut` | **必须** | 所有菜单项右侧必须有图标 |
| 删除样式 | **必须** | `text-destructive focus:text-destructive focus:bg-destructive/10` |
| 分割线 | **必须** | 删除操作前必须有 `DropdownMenuSeparator` |

---

## 卡片视图

### 卡片骨架屏

```tsx
const renderGridSkeleton = () => (
  <div className='grid gap-4 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4'>
    {Array.from({ length: 8 }).map((_, i) => (
      <Card key={i}>
        <CardHeader className='pb-3'>
          <div className='flex items-start justify-between'>
            <div className='flex items-center gap-3'>
              <Skeleton className='h-10 w-10 rounded-lg' />
              <div className='space-y-2'>
                <Skeleton className='h-4 w-24' />
                <Skeleton className='h-5 w-16' />
              </div>
            </div>
            <Skeleton className='h-8 w-8 rounded' />
          </div>
        </CardHeader>
        <CardContent className='space-y-2.5'>
          <Skeleton className='h-8 w-full' />
          <div className='flex justify-between'>
            <Skeleton className='h-5 w-20' />
            <Skeleton className='h-4 w-12' />
          </div>
          <div className='border-t pt-2'>
            <div className='flex gap-4'>
              <Skeleton className='h-4 w-12' />
              <Skeleton className='h-4 w-12' />
              <Skeleton className='h-4 w-12' />
            </div>
          </div>
        </CardContent>
      </Card>
    ))}
  </div>
)
```

### 卡片交互规范

| 交互 | 行为 |
|------|------|
| 点击卡片 | 打开详情抽屉（Sheet） |
| 点击操作菜单 | 阻止冒泡，显示下拉菜单 |
| 悬浮卡片 | 显示操作按钮，卡片阴影加深 `hover:shadow-md` |
| 非激活状态 | 卡片整体降低透明度 `opacity-60` |

### 响应式列数

| 断点 | 列数 | 适用场景 |
|------|------|---------|
| 默认 | 1 列 | 手机 |
| `md` (768px) | 2 列 | 平板竖屏 |
| `lg` (1024px) | 3 列 | 平板横屏 / 小桌面 |
| `xl` (1280px) | 4 列 | 大桌面 |

```tsx
<div className='grid gap-4 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4'>
```

---

## 列表视图

### 列定义文件

```tsx
// {module}-columns.tsx
import { type ColumnDef } from '@tanstack/react-table'
import { DataTableColumnHeader } from '@/components/data-table'

interface ColumnsProps {
  onView: (item: ItemType) => void
  onEdit: (item: ItemType) => void
  onDelete: (item: ItemType) => void
  // ...其他回调
}

export function getColumns({
  onView,
  onEdit,
  onDelete,
}: ColumnsProps): ColumnDef<ItemType>[] {
  return [
    {
      accessorKey: 'name',
      header: ({ column }) => (
        <DataTableColumnHeader column={column} title='名称' />
      ),
      meta: { title: '名称' },  // 必须：用于显示列菜单
      cell: ({ row }) => <div>{row.original.name}</div>,
    },
    {
      accessorKey: 'status',
      header: ({ column }) => (
        <DataTableColumnHeader column={column} title='状态' />
      ),
      meta: { title: '状态' },
      filterFn: (row, id, value: string[]) => {
        return value.includes(row.getValue(id))
      },
      // ...
    },
    {
      id: 'actions',
      cell: ({ row }) => (
        // 操作菜单...
      ),
    },
  ]
}
```

### 表格组件

```tsx
// {module}-table.tsx
import { flexRender, type Table as TableType } from '@tanstack/react-table'

interface ServicesTableProps {
  table: TableType<Service>
  isLoading: boolean
  onRowClick: (item: Service) => void
}

export function ServicesTable({
  table,
  isLoading,
  onRowClick,
}: ServicesTableProps) {
  const columns = table.getAllColumns()

  return (
    <div className='overflow-hidden rounded-md border'>
      <Table>
        <TableHeader>
          {table.getHeaderGroups().map((headerGroup) => (
            <TableRow key={headerGroup.id}>
              {headerGroup.headers.map((header) => (
                <TableHead key={header.id}>
                  {header.isPlaceholder
                    ? null
                    : flexRender(
                        header.column.columnDef.header,
                        header.getContext()
                      )}
                </TableHead>
              ))}
            </TableRow>
          ))}
        </TableHeader>
        <TableBody>
          {isLoading ? (
            // 骨架屏
            Array.from({ length: 10 }).map((_, i) => (
              <TableRow key={i}>
                {columns.map((_, j) => (
                  <TableCell key={j}>
                    <Skeleton className='h-4 w-full' />
                  </TableCell>
                ))}
              </TableRow>
            ))
          ) : table.getRowModel().rows?.length ? (
            table.getRowModel().rows.map((row) => (
              <TableRow
                key={row.id}
                className={cn(
                  'group cursor-pointer',
                  row.original.status !== 'active' && 'opacity-60'
                )}
                onClick={() => onRowClick(row.original)}
              >
                {row.getVisibleCells().map((cell) => (
                  <TableCell key={cell.id}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </TableCell>
                ))}
              </TableRow>
            ))
          ) : (
            <TableRow>
              <TableCell colSpan={columns.length} className='h-24 text-center'>
                暂无数据
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  )
}
```

---

## 翻页组件

> ⚠️ **强制要求**：翻页组件必须使用 `className='mt-auto'` 固定在页面底部。

```tsx
{/* 分页（固定底部） */}
{!isLoading && services.length > 0 && (
  <DataTablePagination table={table} className='mt-auto' />
)}
```

**为什么需要 `mt-auto`？**

配合 `Main` 的 `flex flex-1 flex-col` 布局，`mt-auto` 会将翻页组件推到容器底部，保证页面布局一致性。

---

## 完整主页面示例

```tsx
// index.tsx
export function Services() {
  const navigate = useNavigate()
  const searchParams = useSearch({ strict: false }) as { view?: string }

  // 1. 视图状态
  const initialViewMode = (searchParams.view === 'list' ? 'list' : 'grid') as ViewMode
  const [viewMode, setViewMode] = useState<ViewMode>(initialViewMode)
  const [page, setPage] = useState(1)
  const [pageSize, setPageSize] = useState(12)
  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([])
  const [globalFilter, setGlobalFilter] = useState('')

  // 2. 弹窗状态
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false)
  const [detailSheetOpen, setDetailSheetOpen] = useState(false)
  const [currentRow, setCurrentRow] = useState<Service | null>(null)

  // 3. 同步视图到 URL
  useEffect(() => { /* ... */ }, [viewMode, navigate, searchParams.view])

  // 4. API 查询
  const { data, isLoading } = useServices({ /* ... */ })

  // 5. 操作回调
  const handleView = (item: Service) => { /* ... */ }
  const handleEdit = (item: Service) => { /* ... */ }
  const handleDelete = (item: Service) => { /* ... */ }

  // 6. 列定义
  const columns = useMemo(() => getColumns({ /* ... */ }), [/* deps */])

  // 7. 表格实例
  const table = useReactTable({ /* ... */ })

  return (
    <>
      <Header>...</Header>

      <Main className='flex flex-1 flex-col gap-4 sm:gap-6'>
        {/* 标题区 */}
        <div className='flex flex-wrap items-end justify-between gap-2'>
          ...
        </div>

        {/* 工具栏 */}
        <div className='flex flex-wrap items-center gap-4'>
          <DataTableToolbar table={table} showViewOptions={false} ... />
          <div className='ms-auto flex items-center gap-2'>
            <DataTableViewOptions table={table} />
            <Tabs ...>视图切换</Tabs>
          </div>
        </div>

        {/* 加载骨架屏 */}
        {isLoading && viewMode === 'grid' && renderGridSkeleton()}
        {isLoading && viewMode === 'list' && <ServicesTable table={table} isLoading={true} />}

        {/* 空状态 */}
        {!isLoading && services.length === 0 && (
          <div className='flex h-64 flex-col items-center justify-center gap-4'>
            <PackageSearch className='h-12 w-12 text-muted-foreground' />
            <p className='text-muted-foreground'>暂无数据</p>
          </div>
        )}

        {/* 内容区 */}
        {!isLoading && services.length > 0 && (
          <>
            {viewMode === 'grid' ? renderGridView() : <ServicesTable ... />}
            <DataTablePagination table={table} className='mt-auto' />
          </>
        )}
      </Main>

      {/* 弹窗组件 */}
      <ServicesDetailSheet ... />
      <ConfirmDialog ... />
    </>
  )
}
```

---

## 检查清单

### 核心依赖

- [ ] 使用 `useReactTable` 管理表格状态
- [ ] 导入 `DataTableToolbar`、`DataTablePagination`、`DataTableViewOptions`
- [ ] 配置 `manualPagination: true` 和 `manualFiltering: true`

### 页面布局

- [ ] `Main` 组件使用 `className='flex flex-1 flex-col gap-4 sm:gap-6'`
- [ ] 标题区使用 `flex flex-wrap items-end justify-between gap-2`
- [ ] 组件间距通过 `Main` 的 `gap` 控制，不要使用额外的 `mb-*`

### 视图状态

- [ ] 视图状态持久化到 URL 参数 `?view=list`（grid 为默认不写入）
- [ ] 刷新页面后保持原视图状态
- [ ] 切换视图使用 `replace: true` 避免产生多余历史记录

### 工具栏

- [ ] 使用 `DataTableToolbar` 组件，不要自定义筛选实现
- [ ] 设置 `showViewOptions={false}` 禁用内置显示列
- [ ] 单独添加 `DataTableViewOptions` 放在视图切换器左侧
- [ ] 视图切换器使用 `Tabs` 组件，添加 `aria-label`
- [ ] 工具栏右侧布局：`<div className='ms-auto flex items-center gap-2'>`

### 操作菜单

- [ ] `DropdownMenu` 添加 `modal={false}`
- [ ] `DropdownMenuTrigger` 添加 `onClick={(e) => e.stopPropagation()}`
- [ ] 每个 `DropdownMenuItem` 添加 `onClick={(e) => { e.stopPropagation(); ... }}`
- [ ] `DropdownMenuContent` 添加 `className='w-[160px]'`
- [ ] 所有菜单项使用 `DropdownMenuShortcut` 添加右侧图标
- [ ] 删除操作前添加 `DropdownMenuSeparator`
- [ ] 删除操作使用 `className='text-destructive focus:text-destructive focus:bg-destructive/10'`

### 卡片视图

- [ ] 加载状态使用 Skeleton 骨架屏（不是 Loader2）
- [ ] 空状态显示图标和提示文字
- [ ] 卡片点击打开详情抽屉（Sheet）
- [ ] 卡片添加 `hover:shadow-md` 悬浮效果
- [ ] 操作按钮使用 `opacity-0 group-hover:opacity-100` 悬浮显示
- [ ] 非激活状态卡片降低透明度 `opacity-60`
- [ ] 响应式列数：`md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4`

### 列表视图

- [ ] 创建 `{module}-columns.tsx` 列定义文件
- [ ] 每列添加 `meta: { title: '中文名' }`
- [ ] 创建 `{module}-table.tsx` 表格组件
- [ ] 表格使用 `<div className='overflow-hidden rounded-md border'>` 包裹（不是 Card）
- [ ] 表格行添加 `group cursor-pointer` 支持点击
- [ ] 表格骨架屏使用 Skeleton 组件

### 翻页组件

- [ ] 使用 `DataTablePagination` 组件
- [ ] 添加 `className='mt-auto'` 固定在底部
- [ ] 仅在有数据时显示翻页组件

### 组件复用

- [ ] 两种视图共用同一套操作回调函数
- [ ] 两种视图共用同一套弹窗组件（详情抽屉、确认弹窗）
- [ ] 两种视图的操作菜单选项完全一致
- [ ] 筛选条件对两种视图同时生效

---

## 常见问题

### Q: 为什么不能用自定义筛选组件？

A: `DataTableToolbar` 与 `useReactTable` 深度集成，自定义实现会导致：
- 筛选状态无法同步到表格
- 无法使用 `DataTableViewOptions` 控制列显隐
- 代码风格不统一，维护成本高

### Q: 卡片视图不需要表格，为什么还要用 `useReactTable`？

A: 即使卡片视图不渲染表格，仍需要 `useReactTable` 因为：
- `DataTableToolbar` 需要 `table` 实例进行筛选
- `DataTablePagination` 需要 `table` 实例进行分页
- 两种视图共享筛选/分页状态

### Q: 为什么翻页组件要用 `mt-auto`？

A: 配合 `Main` 的 `flex flex-1 flex-col` 布局，`mt-auto` 会将翻页组件推到容器底部，保证：
- 页面内容较少时，翻页组件仍在底部
- 页面布局一致性
- 符合用户预期的交互位置
