# 订单服务流程规划文档

> 返回 [陪诊员中心总览](./README.md)  
> 状态：✅ 已规划（基础功能已实现）  
> 版本：v1.1  
> 更新日期：2024-12-11

---

## 一、核心概念

### 1.1 订单生命周期

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           订单状态流转图                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   用户操作              系统/陪诊员操作                  管理员操作           │
│                                                                             │
│   ┌─────────┐                                                               │
│   │ pending │ ◄── 用户下单                                                  │
│   └────┬────┘                                                               │
│        │ 用户支付                                                            │
│        ▼                                                                     │
│   ┌─────────┐                                                               │
│   │  paid   │ ◄── 进入抢单池 / 等待派单                                      │
│   └────┬────┘                                                               │
│        │                                                                     │
│        ├──────────────────────┬────────────────────┐                        │
│        │                      │                    │                        │
│        │ 陪诊员抢单           │ 管理员手动派单      │ 系统自动派单           │
│        ▼                      ▼                    ▼                        │
│   ┌─────────┐           ┌─────────┐                                         │
│   │assigned │ ◄─────────│confirmed│ (可选流程)                              │
│   └────┬────┘           └─────────┘                                         │
│        │                                                                     │
│        │ 陪诊员确认到达服务地点                                               │
│        ▼                                                                     │
│   ┌─────────┐                                                               │
│   │ arrived │ ◄── 陪诊员到达                                                 │
│   └────┬────┘                                                               │
│        │ 陪诊员开始服务                                                       │
│        ▼                                                                     │
│   ┌───────────┐                                                             │
│   │in_progress│ ◄── 服务进行中                                               │
│   └─────┬─────┘                                                             │
│         │ 陪诊员完成服务                                                      │
│         ▼                                                                    │
│   ┌───────────┐                                                             │
│   │ completed │ ◄── 服务完成                                                 │
│   └─────┬─────┘                                                             │
│         │                                                                    │
│         ▼                                                                    │
│   ┌───────────┐                                                             │
│   │  评价结算  │ ◄── 用户评价 + 分成入账                                     │
│   └───────────┘                                                             │
│                                                                             │
│   ═══════════════════════════════════════════════════════════════════════   │
│   异常流程：                                                                 │
│                                                                             │
│   pending ───► cancelled    用户取消（未支付）                               │
│   paid ─────► cancelled    用户取消（已支付，全额退款）                       │
│   assigned ─► cancelled    用户取消（已派单，可能扣违约金）                   │
│   任意状态 ─► refunding ──► refunded    退款流程                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 派单模式

| 模式 | 说明 | 适用场景 |
|------|------|---------|
| **抢单模式** | 陪诊员主动抢单，先抢先得 | 订单量大、陪诊员充足 |
| **派单模式** | 管理员手动分配陪诊员 | 精细化运营、VIP订单 |
| **智能派单** | 系统根据规则自动分配 | 规模化运营 |
| **指定模式** | 用户下单时指定陪诊员 | 复购用户、指定服务 |

---

## 二、数据模型

### 2.1 订单模型扩展

```prisma
model Order {
  id               String    @id @default(uuid())
  orderNo          String    @unique @map("order_no")
  
  // 关联
  userId           String    @map("user_id")
  serviceId        String    @map("service_id")
  hospitalId       String?   @map("hospital_id")
  patientId        String?   @map("patient_id")
  escortId         String?   @map("escort_id")         // 陪诊员（可为空）
  
  // 预约信息
  appointmentDate  DateTime  @map("appointment_date")
  appointmentTime  String    @map("appointment_time")   // "09:00"
  department       String?                              // 预约科室
  remarks          String?   @db.Text                   // 备注
  
  // 价格信息
  originalAmount   Decimal   @db.Decimal(10, 2) @map("original_amount")
  paidAmount       Decimal   @db.Decimal(10, 2) @map("paid_amount")
  
  // 分成信息（订单完成时快照）
  commissionRate   Int?      @map("commission_rate")          // 分成比例
  commissionAmount Decimal?  @db.Decimal(10, 2) @map("commission_amount")  // 陪诊员收入
  platformAmount   Decimal?  @db.Decimal(10, 2) @map("platform_amount")    // 平台收入
  
  // 状态
  status           String    @default("pending")
  // pending: 待支付
  // paid: 已支付（待接单）
  // confirmed: 已确认（可选，管理员确认后）
  // assigned: 已派单
  // arrived: 已到达
  // in_progress: 服务中
  // completed: 已完成
  // cancelled: 已取消
  // refunding: 退款中
  // refunded: 已退款
  
  // 派单方式
  assignMethod     String?   @map("assign_method")
  // grab: 陪诊员抢单
  // manual: 管理员派单
  // auto: 系统自动派单
  // user_select: 用户指定
  
  // 时间戳
  paidAt           DateTime? @map("paid_at")
  assignedAt       DateTime? @map("assigned_at")
  arrivedAt        DateTime? @map("arrived_at")
  startedAt        DateTime? @map("started_at")
  completedAt      DateTime? @map("completed_at")
  cancelledAt      DateTime? @map("cancelled_at")
  
  // 取消/退款
  cancelReason     String?   @map("cancel_reason")
  refundAmount     Decimal?  @db.Decimal(10, 2) @map("refund_amount")
  refundedAt       DateTime? @map("refunded_at")
  
  // 超时保护
  assignDeadline   DateTime? @map("assign_deadline")      // 派单截止时间
  serviceDeadline  DateTime? @map("service_deadline")     // 服务超时时间
  
  // 接单前工作状态（用于服务完成后恢复）
  preAssignWorkStatus String? @map("pre_assign_work_status")
  
  // 服务证据
  arrivePhotos     String[]  @map("arrive_photos")        // 到达打卡照片
  completePhotos   String[]  @map("complete_photos")      // 完成服务照片
  
  // 预约位置详情
  appointmentAddress  String? @map("appointment_address")  // 具体就诊地址
  appointmentBuilding String? @map("appointment_building") // 楼栋/诊室
  
  // 陪诊员对用户的评价（双向评价）
  escortRating     Int?      @map("escort_rating")        // 陪诊员对用户的评分
  escortRemark     String?   @map("escort_remark")        // 陪诊员备注
  
  createdAt        DateTime  @default(now()) @map("created_at")
  updatedAt        DateTime  @updatedAt @map("updated_at")
  
  // 关联
  user             User      @relation(fields: [userId], references: [id])
  service          Service   @relation(fields: [serviceId], references: [id])
  hospital         Hospital? @relation(fields: [hospitalId], references: [id])
  patient          Patient?  @relation(fields: [patientId], references: [id])
  escort           Escort?   @relation(fields: [escortId], references: [id])
  review           EscortReview?
  
  @@index([userId])
  @@index([escortId])
  @@index([status])
  @@index([appointmentDate])
  @@map("orders")
}
```

### 2.2 订单操作日志

```prisma
model OrderLog {
  id          String   @id @default(uuid())
  orderId     String   @map("order_id")
  
  action      String                         // 操作类型
  fromStatus  String?  @map("from_status")   // 原状态
  toStatus    String?  @map("to_status")     // 新状态
  operatorType String  @map("operator_type") // user, escort, admin, system
  operatorId  String?  @map("operator_id")   // 操作人 ID
  remark      String?                        // 备注
  extra       Json?                          // 额外信息
  
  createdAt   DateTime @default(now()) @map("created_at")
  
  order       Order    @relation(fields: [orderId], references: [id])
  
  @@index([orderId])
  @@map("order_logs")
}
```

---

## 三、业务逻辑

### 3.1 抢单逻辑

```typescript
async function grabOrder(userId: string, orderId: string): Promise<Order> {
  // 1. 获取陪诊员信息
  const escort = await prisma.escort.findFirst({
    where: { userId }
  });
  
  if (!escort) {
    throw new NotFoundException('您不是陪诊员');
  }
  
  // 2. 检查陪诊员状态
  if (escort.status !== 'active') {
    throw new ForbiddenException('您的账号未激活');
  }
  
  if (escort.workStatus !== 'working') {
    throw new BadRequestException('请先开启接单状态');
  }
  
  // 3. 使用事务 + 条件更新保证并发安全
  return prisma.$transaction(async (tx) => {
    // 原子抢占：只有 status 为 paid 且 escortId 为空的订单可以被抢占
    const { count } = await tx.order.updateMany({
      where: {
        id: orderId,
        status: 'paid',
        escortId: null,
      },
      data: {
        status: 'assigned',
        escortId: escort.id,
        assignMethod: 'grab',
        assignedAt: new Date(),
      },
    });

    if (count !== 1) {
      throw new BadRequestException('订单已被抢走或不可抢');
    }

    // 4. 更新陪诊员订单数
    await tx.escort.update({
      where: { id: escort.id },
      data: { orderCount: { increment: 1 } },
    });
    
    // 5. 记录操作日志
    await tx.orderLog.create({
      data: {
        orderId,
        action: 'grab',
        fromStatus: 'paid',
        toStatus: 'assigned',
        operatorType: 'escort',
        operatorId: escort.id,
      }
    });

    // 6. 返回更新后的订单
    const order = await tx.order.findUnique({
      where: { id: orderId },
      include: {
        service: true,
        hospital: true,
        patient: true,
      },
    });
    
    // 7. 发送通知给用户
    await sendUserNotification(order.userId, {
      type: 'order_assigned',
      orderId,
      escortName: escort.name,
    });
    
    return order;
  });
}
```

### 3.2 服务流程状态流转

```typescript
// 确认到达
async function arriveOrder(userId: string, orderId: string): Promise<void> {
  const escort = await getEscortByUserId(userId);
  
  await prisma.$transaction(async (tx) => {
    const { count } = await tx.order.updateMany({
      where: {
        id: orderId,
        escortId: escort.id,
        status: 'assigned',
      },
      data: {
        status: 'arrived',
        arrivedAt: new Date(),
      },
    });

    if (count !== 1) {
      throw new BadRequestException('状态已变化或无权操作');
    }
    
    await tx.orderLog.create({
      data: {
        orderId,
        action: 'arrive',
        fromStatus: 'assigned',
        toStatus: 'arrived',
        operatorType: 'escort',
        operatorId: escort.id,
      }
    });
  });
  
  // 通知用户
  await notifyUser(orderId, 'escort_arrived');
}

// 开始服务
async function startOrder(userId: string, orderId: string): Promise<void> {
  const escort = await getEscortByUserId(userId);
  
  await prisma.$transaction(async (tx) => {
    const { count } = await tx.order.updateMany({
      where: {
        id: orderId,
        escortId: escort.id,
        status: 'arrived',
      },
      data: {
        status: 'in_progress',
        startedAt: new Date(),
      },
    });

    if (count !== 1) {
      throw new BadRequestException('状态已变化或无权操作');
    }
    
    // 更新陪诊员状态为忙碌
    await tx.escort.update({
      where: { id: escort.id },
      data: { workStatus: 'busy' },
    });
    
    await tx.orderLog.create({
      data: {
        orderId,
        action: 'start',
        fromStatus: 'arrived',
        toStatus: 'in_progress',
        operatorType: 'escort',
        operatorId: escort.id,
      }
    });
  });
  
  // 通知用户
  await notifyUser(orderId, 'service_started');
}

// 完成服务
async function completeOrder(userId: string, orderId: string): Promise<void> {
  const escort = await getEscortByUserId(userId);
  
  await prisma.$transaction(async (tx) => {
    // 获取订单信息用于计算分成
    const order = await tx.order.findUnique({
      where: { id: orderId },
      include: { service: true }
    });
    
    if (!order || order.escortId !== escort.id || order.status !== 'in_progress') {
      throw new BadRequestException('状态已变化或无权操作');
    }
    
    // 计算分成
    const { commissionRate, commissionAmount, platformAmount } = 
      calculateCommission(order, escort);
    
    // 更新订单
    await tx.order.update({
      where: { id: orderId },
      data: {
        status: 'completed',
        completedAt: new Date(),
        commissionRate,
        commissionAmount,
        platformAmount,
      },
    });
    
    // 恢复陪诊员状态
    await tx.escort.update({
      where: { id: escort.id },
      data: { workStatus: 'working' },
    });
    
    // 更新陪诊员钱包
    await tx.escortWallet.update({
      where: { escortId: escort.id },
      data: {
        balance: { increment: commissionAmount },
        totalEarned: { increment: commissionAmount },
      }
    });
    
    await tx.orderLog.create({
      data: {
        orderId,
        action: 'complete',
        fromStatus: 'in_progress',
        toStatus: 'completed',
        operatorType: 'escort',
        operatorId: escort.id,
        extra: { commissionRate, commissionAmount },
      }
    });
  });
  
  // 通知用户评价
  await notifyUser(orderId, 'service_completed');
}
```

### 3.3 抢单池查询

```typescript
async function getOrderPool(
  userId: string, 
  params: { cityCode?: string; hospitalId?: string }
): Promise<Order[]> {
  const escort = await getEscortByUserId(userId);
  
  // 非接单状态返回空
  if (escort.workStatus !== 'working') {
    return [];
  }
  
  const where: any = {
    status: 'paid',
    escortId: null,
    // 只显示预约日期在今天或之后的订单
    appointmentDate: { gte: new Date() },
  };
  
  // 可选：按城市筛选
  if (params.cityCode) {
    where.hospital = { cityCode: params.cityCode };
  }
  
  // 可选：按医院筛选（陪诊员关联的医院）
  if (params.hospitalId) {
    where.hospitalId = params.hospitalId;
  }
  
  // 可选：只显示陪诊员关联医院的订单
  const escortHospitalIds = escort.hospitals.map(h => h.hospitalId);
  if (escortHospitalIds.length > 0) {
    where.hospitalId = { in: escortHospitalIds };
  }
  
  return prisma.order.findMany({
    where,
    include: {
      service: { select: { id: true, name: true } },
      hospital: { select: { id: true, name: true, shortName: true, address: true } },
    },
    orderBy: [
      { appointmentDate: 'asc' },
      { appointmentTime: 'asc' },
    ],
    take: 50,
  });
}
```

### 3.4 并发安全措施

```typescript
// 使用分布式锁确保并发安全
import Redlock from 'redlock';

const redlock = new Redlock([redis], {
  driftFactor: 0.01,
  retryCount: 3,
  retryDelay: 200,
  retryJitter: 200,
});

// 带锁的抢单操作
async function grabOrderWithLock(userId: string, orderId: string): Promise<Order> {
  const lockKey = `order:grab:${orderId}`;
  
  let lock: Lock | null = null;
  try {
    // 获取分布式锁
    lock = await redlock.acquire([lockKey], 5000);
    
    // 执行抢单逻辑
    return await grabOrder(userId, orderId);
  } finally {
    if (lock) {
      await lock.release();
    }
  }
}

// 陪诊员操作锁（防止同时完成多个订单导致状态冲突）
async function completeOrderWithLock(userId: string, orderId: string): Promise<void> {
  const escort = await getEscortByUserId(userId);
  const lockKey = `escort:operation:${escort.id}`;
  
  let lock: Lock | null = null;
  try {
    lock = await redlock.acquire([lockKey], 10000);
    await completeOrder(userId, orderId);
  } finally {
    if (lock) {
      await lock.release();
    }
  }
}

// 提现操作锁（防止同时申请多次提现）
async function requestWithdrawalWithLock(userId: string, amount: number): Promise<Withdrawal> {
  const escort = await getEscortByUserId(userId);
  const lockKey = `escort:withdraw:${escort.id}`;
  
  let lock: Lock | null = null;
  try {
    lock = await redlock.acquire([lockKey], 10000);
    return await requestWithdrawal(userId, amount, 'wechat');
  } finally {
    if (lock) {
      await lock.release();
    }
  }
}
```

### 3.5 智能派单算法

```typescript
interface DispatchScore {
  escortId: string;
  escortName: string;
  totalScore: number;
  factors: {
    distance: number;           // 距离得分（权重 30%）
    hospitalFamiliarity: number; // 医院熟悉度（权重 25%）
    rating: number;             // 评分得分（权重 20%）
    levelWeight: number;        // 等级权重（权重 15%）
    availability: number;       // 空闲度（权重 10%）
  };
}

interface DispatchConfig {
  weights: {
    distance: number;           // 0.30
    hospitalFamiliarity: number; // 0.25
    rating: number;             // 0.20
    levelWeight: number;        // 0.15
    availability: number;       // 0.10
  };
  maxDistanceKm: number;        // 最大服务距离
  minRating: number;            // 最低评分要求
}

async function smartDispatch(order: Order, config?: DispatchConfig): Promise<string | null> {
  const defaultConfig: DispatchConfig = {
    weights: {
      distance: 0.30,
      hospitalFamiliarity: 0.25,
      rating: 0.20,
      levelWeight: 0.15,
      availability: 0.10,
    },
    maxDistanceKm: 30,
    minRating: 4.0,
  };
  
  const cfg = { ...defaultConfig, ...config };
  
  // 1. 获取候选陪诊员
  const candidates = await getAvailableEscortsForOrder(order);
  
  if (candidates.length === 0) {
    return null;
  }
  
  // 2. 计算每个陪诊员的得分
  const scored: DispatchScore[] = [];
  
  for (const escort of candidates) {
    const factors = await calculateDispatchFactors(escort, order);
    
    // 距离过远或评分过低，跳过
    if (factors.distanceKm > cfg.maxDistanceKm || escort.rating < cfg.minRating) {
      continue;
    }
    
    // 计算总分
    const totalScore = 
      factors.distance * cfg.weights.distance +
      factors.hospitalFamiliarity * cfg.weights.hospitalFamiliarity +
      factors.rating * cfg.weights.rating +
      factors.levelWeight * cfg.weights.levelWeight +
      factors.availability * cfg.weights.availability;
    
    scored.push({
      escortId: escort.id,
      escortName: escort.name,
      totalScore,
      factors,
    });
  }
  
  // 3. 按得分排序
  scored.sort((a, b) => b.totalScore - a.totalScore);
  
  // 4. 返回得分最高的陪诊员
  return scored[0]?.escortId || null;
}

async function calculateDispatchFactors(escort: Escort, order: Order): Promise<{
  distance: number;
  distanceKm: number;
  hospitalFamiliarity: number;
  rating: number;
  levelWeight: number;
  availability: number;
}> {
  // 距离得分（越近越高）
  let distanceKm = 999;
  let distanceScore = 0;
  
  if (escort.lastLatitude && escort.lastLongitude && order.hospital) {
    distanceKm = calculateDistance(
      escort.lastLatitude,
      escort.lastLongitude,
      order.hospital.latitude,
      order.hospital.longitude
    );
    // 距离在5km内得满分，30km外得0分
    distanceScore = Math.max(0, 100 - (distanceKm - 5) * (100 / 25));
  }
  
  // 医院熟悉度（是否关联该医院）
  const escortHospitals = await prisma.escortHospital.findMany({
    where: { escortId: escort.id }
  });
  const isFamiliar = escortHospitals.some(eh => eh.hospitalId === order.hospitalId);
  const hospitalScore = isFamiliar ? 100 : 50;
  
  // 评分得分
  const ratingScore = (escort.rating / 5) * 100;
  
  // 等级权重
  const levelScores = {
    senior: 100,
    intermediate: 75,
    junior: 50,
    trainee: 25,
  };
  const levelScore = levelScores[escort.level] || 50;
  
  // 空闲度（当日订单越少越高）
  const todayOrderCount = await prisma.order.count({
    where: {
      escortId: escort.id,
      appointmentDate: order.appointmentDate,
      status: { notIn: ['cancelled', 'refunded'] }
    }
  });
  const availabilityScore = Math.max(0, 100 - todayOrderCount * 20);
  
  return {
    distance: distanceScore,
    distanceKm,
    hospitalFamiliarity: hospitalScore,
    rating: ratingScore,
    levelWeight: levelScore,
    availability: availabilityScore,
  };
}

function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371; // 地球半径（km）
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

// 自动派单定时任务
@Cron('*/5 * * * *')  // 每5分钟执行
async function autoDispatchPendingOrders(): Promise<void> {
  // 获取超过10分钟未被抢的订单
  const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000);
  
  const pendingOrders = await prisma.order.findMany({
    where: {
      status: 'paid',
      escortId: null,
      paidAt: { lte: tenMinutesAgo },
    },
    include: { hospital: true }
  });
  
  for (const order of pendingOrders) {
    const escortId = await smartDispatch(order);
    
    if (escortId) {
      await prisma.order.update({
        where: { id: order.id },
        data: {
          status: 'assigned',
          escortId,
          assignMethod: 'auto',
          assignedAt: new Date(),
        }
      });
      
      // 发送通知
      await notifyEscort(escortId, 'order_auto_assigned', order);
      await notifyUser(order.userId, 'order_assigned', order);
    }
  }
}
```

### 3.6 管理员派单

```typescript
async function assignOrder(
  orderId: string, 
  escortId: string, 
  adminId: string
): Promise<Order> {
  const escort = await prisma.escort.findUnique({
    where: { id: escortId }
  });
  
  if (!escort || escort.status !== 'active') {
    throw new BadRequestException('陪诊员不存在或未激活');
  }
  
  return prisma.$transaction(async (tx) => {
    const { count } = await tx.order.updateMany({
      where: {
        id: orderId,
        status: { in: ['paid', 'confirmed'] },
      },
      data: {
        status: 'assigned',
        escortId: escort.id,
        assignMethod: 'manual',
        assignedAt: new Date(),
      },
    });

    if (count !== 1) {
      throw new BadRequestException('订单状态不允许派单');
    }
    
    await tx.escort.update({
      where: { id: escort.id },
      data: { orderCount: { increment: 1 } },
    });
    
    await tx.orderLog.create({
      data: {
        orderId,
        action: 'assign',
        fromStatus: 'paid',
        toStatus: 'assigned',
        operatorType: 'admin',
        operatorId: adminId,
        remark: `管理员派单给 ${escort.name}`,
      }
    });
    
    // 通知陪诊员
    if (escort.userId) {
      await sendEscortNotification(escort.userId, {
        type: 'order_assigned',
        orderId,
      });
    }
    
    return tx.order.findUnique({
      where: { id: orderId },
      include: { service: true, hospital: true, patient: true, escort: true },
    });
  });
}
```

---

## 四、API 设计

### 4.1 陪诊员端 API

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/escort/orders/pool` | 获取抢单池 |
| POST | `/escort/orders/:id/grab` | 抢单 |
| POST | `/escort/orders/:id/arrive` | 确认到达 |
| POST | `/escort/orders/:id/start` | 开始服务 |
| POST | `/escort/orders/:id/complete` | 完成服务 |
| GET | `/escort/orders/:id` | 获取订单详情 |
| GET | `/escort/orders` | 获取订单列表 |

### 4.2 管理端 API

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/admin/orders` | 获取订单列表 |
| GET | `/admin/orders/:id` | 获取订单详情 |
| POST | `/admin/orders/:id/assign` | 派单 |
| POST | `/admin/orders/:id/cancel` | 取消订单 |
| GET | `/admin/orders/:id/logs` | 获取订单日志 |

### 4.3 请求/响应示例

```typescript
// POST /escort/orders/:id/grab 抢单
// Request: 无需 body

// Response:
{
  "code": 0,
  "data": {
    "id": "xxx",
    "orderNo": "202412200001",
    "status": "assigned",
    "service": { "id": "s1", "name": "全程陪诊" },
    "hospital": { "id": "h1", "name": "北京协和医院" },
    "patient": { "id": "p1", "name": "张先生" },
    "appointmentDate": "2024-12-20",
    "appointmentTime": "09:00",
    "paidAmount": 299
  }
}

// Error Response (订单已被抢):
{
  "code": 400,
  "message": "订单已被抢走或不可抢"
}
```

---

## 五、消息通知

### 5.1 通知类型

| 事件 | 接收方 | 通知内容 |
|------|--------|---------|
| 订单支付成功 | 用户 | 订单支付成功，等待陪诊员接单 |
| 订单被抢/派单 | 用户 | 陪诊员已接单，xxx将为您服务 |
| 订单被抢/派单 | 陪诊员 | 您有新订单，请及时查看 |
| 陪诊员到达 | 用户 | 陪诊员已到达，请知悉 |
| 服务开始 | 用户 | 服务已开始，如有问题请联系客服 |
| 服务完成 | 用户 | 服务已完成，请评价陪诊员 |
| 订单取消 | 陪诊员 | 您的订单已被取消，原因：xxx |

### 5.2 通知实现

```typescript
async function notifyUser(orderId: string, event: string): Promise<void> {
  const order = await prisma.order.findUnique({
    where: { id: orderId },
    include: { user: true, escort: true, service: true }
  });
  
  const templates = {
    order_assigned: {
      title: '陪诊员已接单',
      content: `${order.escort.name}将为您提供${order.service.name}服务`,
    },
    escort_arrived: {
      title: '陪诊员已到达',
      content: '陪诊员已到达服务地点，请做好准备',
    },
    service_started: {
      title: '服务已开始',
      content: '陪诊服务已开始，如有问题请联系客服',
    },
    service_completed: {
      title: '服务已完成',
      content: '本次服务已完成，请对陪诊员进行评价',
      action: { type: 'review', orderId },
    },
  };
  
  const template = templates[event];
  if (!template) return;
  
  // 站内消息
  await createMessage({
    userId: order.userId,
    title: template.title,
    content: template.content,
    type: 'order',
    extra: { orderId, action: template.action },
  });
  
  // 微信订阅消息
  if (order.user.openId) {
    await sendWechatSubscribeMessage(order.user.openId, event, {
      orderId,
      serviceName: order.service.name,
      escortName: order.escort?.name,
    });
  }
}
```

---

## 六、验收标准

### 抢单功能
- [ ] 陪诊员可看到抢单池中的订单
- [ ] 休息状态无法抢单
- [ ] 并发抢单时只有一人成功
- [ ] 抢单成功后订单状态正确变更

### 服务流程
- [ ] 可正确执行「确认到达」操作
- [ ] 可正确执行「开始服务」操作
- [ ] 可正确执行「完成服务」操作
- [ ] 每步操作都有状态校验
- [ ] 服务中时陪诊员状态为 busy

### 派单功能
- [ ] 管理员可手动派单
- [ ] 派单后陪诊员收到通知
- [ ] 用户可在下单时指定陪诊员

### 通知功能
- [ ] 关键节点有消息通知
- [ ] 通知内容准确

### 日志记录
- [ ] 每个状态变更都有日志
- [ ] 日志记录操作人和时间

---

## 七、服务异常处理

### 7.1 异常场景定义

```typescript
enum ServiceException {
  ESCORT_LATE = 'escort_late',           // 陪诊员迟到
  ESCORT_NO_SHOW = 'escort_no_show',     // 陪诊员爽约
  SERVICE_INTERRUPTED = 'service_interrupted', // 服务中断
  USER_COMPLAINT = 'user_complaint',     // 用户投诉
  FORCE_MAJEURE = 'force_majeure',       // 不可抗力
}

interface ExceptionHandleResult {
  userCompensation: number;    // 用户赔偿金额
  escortPenalty: number;       // 陪诊员扣款
  escortPointDeduction: number; // 陪诊员扣分
  autoRefund: boolean;         // 是否自动退款
  escortSuspend: boolean;      // 是否封禁陪诊员
}
```

### 7.2 迟到处理

```typescript
// 陪诊员迟到检测（预约时间后15/30分钟未确认到达）
@Cron('*/5 * * * *')
async function checkEscortLate(): Promise<void> {
  const now = new Date();
  
  // 查找已派单但未到达的订单
  const orders = await prisma.order.findMany({
    where: {
      status: 'assigned',
      appointmentDate: {
        gte: startOfDay(now),
        lte: endOfDay(now),
      }
    },
    include: { escort: true, user: true }
  });
  
  for (const order of orders) {
    const appointmentTime = parseAppointmentDateTime(order.appointmentDate, order.appointmentTime);
    const minutesLate = differenceInMinutes(now, appointmentTime);
    
    if (minutesLate >= 15 && minutesLate < 30) {
      // 迟到15分钟：记录警告
      await handleLateness(order, 'warning', minutesLate);
    } else if (minutesLate >= 30 && minutesLate < 60) {
      // 迟到30分钟：扣除10%分成
      await handleLateness(order, 'penalty', minutesLate);
    } else if (minutesLate >= 60) {
      // 迟到60分钟：视为爽约
      await handleNoShow(order);
    }
  }
}

async function handleLateness(order: Order, severity: 'warning' | 'penalty', minutes: number): Promise<void> {
  const existingLog = await prisma.orderLog.findFirst({
    where: {
      orderId: order.id,
      action: `lateness_${severity}`,
    }
  });
  
  if (existingLog) return; // 已处理过
  
  await prisma.orderLog.create({
    data: {
      orderId: order.id,
      action: `lateness_${severity}`,
      operatorType: 'system',
      remark: `陪诊员迟到 ${minutes} 分钟`,
      extra: { minutes, severity },
    }
  });
  
  if (severity === 'penalty') {
    // 记录扣款（在订单完成时执行）
    await prisma.order.update({
      where: { id: order.id },
      data: {
        extra: {
          ...(order.extra as object || {}),
          latePenaltyRate: 10, // 扣除10%分成
        }
      }
    });
    
    // 通知陪诊员
    await notificationService.send({
      event: 'escort_late_warning',
      recipientId: order.escortId!,
      recipientType: 'escort',
      data: {
        orderNo: order.orderNo,
        minutesLate: minutes,
        penalty: '将扣除本单10%分成',
      }
    });
  }
  
  // 通知用户
  await notificationService.send({
    event: 'escort_late_notice',
    recipientId: order.userId,
    recipientType: 'user',
    data: {
      orderNo: order.orderNo,
      escortName: order.escort?.name,
      minutesLate: minutes,
    }
  });
}
```

### 7.3 爽约处理

```typescript
async function handleNoShow(order: Order): Promise<void> {
  await prisma.$transaction(async (tx) => {
    // 1. 取消订单，全额退款
    await tx.order.update({
      where: { id: order.id },
      data: {
        status: 'refunding',
        cancelReason: '陪诊员爽约',
        cancelledAt: new Date(),
      }
    });
    
    // 2. 陪诊员扣分/降级/封禁
    const escort = await tx.escort.findUnique({
      where: { id: order.escortId! }
    });
    
    // 检查历史爽约次数
    const noShowCount = await tx.orderLog.count({
      where: {
        order: { escortId: order.escortId },
        action: 'no_show',
        createdAt: { gte: subMonths(new Date(), 3) }  // 近3个月
      }
    });
    
    let penalty = {};
    if (noShowCount >= 2) {
      // 3次爽约，封禁账号
      penalty = { status: 'suspended' };
    } else if (noShowCount >= 1) {
      // 2次爽约，降级
      const nextLevel = getLowerLevel(escort!.level);
      if (nextLevel) {
        penalty = { level: nextLevel };
      }
    }
    
    await tx.escort.update({
      where: { id: order.escortId! },
      data: {
        ...penalty,
        rating: { decrement: 0.5 }, // 扣0.5分
      }
    });
    
    // 3. 记录日志
    await tx.orderLog.create({
      data: {
        orderId: order.id,
        action: 'no_show',
        operatorType: 'system',
        remark: '陪诊员爽约，订单自动取消',
        extra: { noShowCount: noShowCount + 1 },
      }
    });
    
    // 4. 用户补偿（赠送优惠券）
    await grantCompensationCoupon(order.userId, '爽约补偿');
  });
  
  // 5. 发送通知
  await notificationService.send({
    event: 'order_cancelled_no_show',
    recipientId: order.userId,
    recipientType: 'user',
    data: {
      orderNo: order.orderNo,
      refundAmount: order.paidAmount,
      compensationCoupon: '¥20优惠券',
    }
  });
  
  await notificationService.send({
    event: 'escort_no_show_penalty',
    recipientId: order.escortId!,
    recipientType: 'escort',
    data: {
      orderNo: order.orderNo,
      penalty: '评分扣0.5，可能影响等级',
    }
  });
}
```

### 7.4 服务中断处理

```typescript
async function handleServiceInterruption(
  orderId: string,
  reason: 'escort_quit' | 'user_cancel' | 'force_majeure',
  description: string
): Promise<void> {
  const order = await prisma.order.findUnique({
    where: { id: orderId },
    include: { escort: true }
  });
  
  if (!order || order.status !== 'in_progress') {
    throw new BadRequestException('订单状态不允许此操作');
  }
  
  await prisma.$transaction(async (tx) => {
    switch (reason) {
      case 'escort_quit':
        // 陪诊员主动放弃：全额退款 + 陪诊员扣分 + 赔偿
        await tx.order.update({
          where: { id: orderId },
          data: {
            status: 'refunding',
            cancelReason: `陪诊员放弃服务：${description}`,
          }
        });
        
        await tx.escort.update({
          where: { id: order.escortId! },
          data: { rating: { decrement: 1.0 } }
        });
        break;
        
      case 'user_cancel':
        // 用户取消：部分退款（按服务进度）
        const refundRate = calculatePartialRefundRate(order);
        await tx.order.update({
          where: { id: orderId },
          data: {
            status: 'refunding',
            refundAmount: Number(order.paidAmount) * refundRate,
            cancelReason: `用户取消：${description}`,
          }
        });
        break;
        
      case 'force_majeure':
        // 不可抗力：全额退款，无扣分
        await tx.order.update({
          where: { id: orderId },
          data: {
            status: 'refunding',
            refundAmount: order.paidAmount,
            cancelReason: `不可抗力：${description}`,
          }
        });
        break;
    }
    
    // 恢复陪诊员状态
    await tx.escort.update({
      where: { id: order.escortId! },
      data: { workStatus: 'working' }
    });
    
    await tx.orderLog.create({
      data: {
        orderId,
        action: 'service_interrupted',
        operatorType: 'system',
        remark: `服务中断：${reason} - ${description}`,
      }
    });
  });
}
```

### 7.5 投诉处理流程

```typescript
interface Complaint {
  id: string;
  orderId: string;
  userId: string;
  escortId: string;
  type: 'service_quality' | 'attitude' | 'late' | 'no_show' | 'other';
  description: string;
  evidence: string[];  // 图片/视频证据
  status: 'pending' | 'investigating' | 'resolved' | 'rejected';
  result?: ComplaintResult;
}

interface ComplaintResult {
  userRefund: number;
  userCoupon: number;
  escortPenalty: 'none' | 'warning' | 'deduct_points' | 'downgrade' | 'suspend';
  resolution: string;
}

async function handleComplaint(complaint: Complaint, result: ComplaintResult): Promise<void> {
  await prisma.$transaction(async (tx) => {
    // 1. 更新投诉状态
    await tx.complaint.update({
      where: { id: complaint.id },
      data: {
        status: 'resolved',
        result,
        resolvedAt: new Date(),
      }
    });
    
    // 2. 用户赔偿
    if (result.userRefund > 0) {
      await initiatePartialRefund(complaint.orderId, result.userRefund);
    }
    if (result.userCoupon > 0) {
      await grantCompensationCoupon(complaint.userId, '投诉补偿', result.userCoupon);
    }
    
    // 3. 陪诊员处罚
    switch (result.escortPenalty) {
      case 'warning':
        await createWarningRecord(complaint.escortId, complaint.id);
        break;
      case 'deduct_points':
        await tx.escort.update({
          where: { id: complaint.escortId },
          data: { rating: { decrement: 0.5 } }
        });
        break;
      case 'downgrade':
        await downgradeEscort(complaint.escortId);
        break;
      case 'suspend':
        await tx.escort.update({
          where: { id: complaint.escortId },
          data: { status: 'suspended' }
        });
        break;
    }
    
    // 4. 记录处理日志
    await tx.orderLog.create({
      data: {
        orderId: complaint.orderId,
        action: 'complaint_resolved',
        operatorType: 'admin',
        remark: result.resolution,
        extra: result,
      }
    });
  });
  
  // 5. 通知双方
  await notifyComplaintResult(complaint, result);
}
```

---

## 八、工作时段冲突检测

```typescript
async function checkTimeConflict(
  escortId: string, 
  appointmentDate: Date,
  appointmentTime: string,
  serviceDurationMinutes: number = 120  // 默认2小时
): Promise<{ hasConflict: boolean; conflictReason?: string }> {
  const escort = await prisma.escort.findUnique({
    where: { id: escortId },
    include: { hospitals: true }
  });
  
  if (!escort) {
    return { hasConflict: true, conflictReason: '陪诊员不存在' };
  }
  
  // 1. 检查陪诊员服务时段配置
  const serviceHours = escort.serviceHours ? JSON.parse(escort.serviceHours) : null;
  if (serviceHours?.enabled) {
    const dayOfWeek = appointmentDate.getDay();
    const dayConfig = serviceHours.weekdays?.[dayOfWeek];
    
    if (!dayConfig?.enabled) {
      return { hasConflict: true, conflictReason: '该陪诊员当天不服务' };
    }
    
    const isInSlot = dayConfig.slots?.some(slot => 
      appointmentTime >= slot.start && appointmentTime <= slot.end
    );
    
    if (!isInSlot) {
      return { hasConflict: true, conflictReason: '该时段不在陪诊员服务时间内' };
    }
  }
  
  // 2. 检查每日接单上限
  if (escort.currentDailyOrders >= escort.maxDailyOrders) {
    return { hasConflict: true, conflictReason: '该陪诊员今日接单已达上限' };
  }
  
  // 3. 检查与已有订单的时间冲突
  const existingOrders = await prisma.order.findMany({
    where: {
      escortId,
      appointmentDate,
      status: { in: ['assigned', 'arrived', 'in_progress'] }
    }
  });
  
  const newStartMinutes = parseTimeToMinutes(appointmentTime);
  const newEndMinutes = newStartMinutes + serviceDurationMinutes;
  
  for (const order of existingOrders) {
    const orderStart = parseTimeToMinutes(order.appointmentTime);
    const orderEnd = orderStart + serviceDurationMinutes;
    
    // 检查时间重叠
    if (!(newEndMinutes <= orderStart || newStartMinutes >= orderEnd)) {
      return { 
        hasConflict: true, 
        conflictReason: `与订单 ${order.orderNo} 时间冲突` 
      };
    }
  }
  
  return { hasConflict: false };
}

function parseTimeToMinutes(time: string): number {
  const [hours, minutes] = time.split(':').map(Number);
  return hours * 60 + minutes;
}

// 在抢单/派单前调用
async function validateBeforeAssign(escortId: string, order: Order): Promise<void> {
  const { hasConflict, conflictReason } = await checkTimeConflict(
    escortId,
    order.appointmentDate,
    order.appointmentTime
  );
  
  if (hasConflict) {
    throw new BadRequestException(conflictReason);
  }
}
```

---

## 九、变更记录

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|---------|------|
| v1.0 | 2024-12-11 | 初始版本 | - |
| v1.1 | 2024-12-11 | 补充订单扩展字段、分布式锁并发安全、智能派单算法、服务异常处理、时间冲突检测 | - |
