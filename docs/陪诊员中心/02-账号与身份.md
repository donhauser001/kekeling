# 账号与身份规划文档

> 返回 [陪诊员中心总览](./README.md)  
> 状态：✅ 已规划

---

## 一、核心概念

### 1.1 双重身份体系

平台采用 **单账号双身份** 设计，用户和陪诊员共用同一账号体系：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            账号体系架构                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                          ┌──────────────────┐                               │
│                          │      User        │                               │
│                          │   (用户账号)      │                               │
│                          │                  │                               │
│                          │ · id             │                               │
│                          │ · phone ←────────┼── 唯一标识                     │
│                          │ · openId         │                               │
│                          │ · name           │                               │
│                          └────────┬─────────┘                               │
│                                   │                                         │
│                        ┌──────────┴──────────┐                              │
│                        │                     │                              │
│                        ▼                     ▼                              │
│              ┌──────────────────┐   ┌──────────────────┐                    │
│              │    普通用户       │   │    陪诊员身份    │                    │
│              │                  │   │                  │                    │
│              │ · 预约服务       │   │ · Escort 记录    │                    │
│              │ · 管理就诊人     │   │ · userId 关联    │                    │
│              │ · 查看订单       │   │ · 工作台入口     │                    │
│              │ · 评价陪诊员     │   │ · 接单/服务      │                    │
│              └──────────────────┘   └──────────────────┘                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 绑定机制

```
管理员操作                    用户操作                     系统处理
┌────────────┐              ┌────────────┐              ┌────────────┐
│ 创建陪诊员  │              │ 微信登录   │              │ 身份识别   │
│ phone:     │              │ 授权手机号 │              │            │
│ 138xxx     │              │ 138xxx     │              │            │
└─────┬──────┘              └─────┬──────┘              └─────┬──────┘
      │                           │                           │
      │                           │                           │
      ▼                           ▼                           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              自动绑定流程                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Step 1: 管理员创建陪诊员                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ INSERT INTO escorts (phone, name, ...) VALUES ('138xxx', '张护士')   │   │
│  │ // userId 为空，等待用户绑定                                          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Step 2: 用户登录并绑定手机号                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ // 微信授权获取手机号后触发                                           │   │
│  │ const user = await upsertUser({ phone: '138xxx', openId: 'xxx' });   │   │
│  │                                                                      │   │
│  │ // 检查是否存在对应的陪诊员记录                                        │   │
│  │ const escort = await findEscortByPhone('138xxx');                    │   │
│  │ if (escort && !escort.userId) {                                      │   │
│  │   await updateEscort(escort.id, { userId: user.id });                │   │
│  │   // 绑定成功！                                                       │   │
│  │ }                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Step 3: 身份识别                                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ // 用户每次进入小程序时                                               │   │
│  │ const escort = await findEscortByUserId(currentUser.id);             │   │
│  │ if (escort && escort.status === 'active') {                          │   │
│  │   // 显示陪诊员工作台入口                                             │   │
│  │   setIsEscort(true);                                                  │   │
│  │ }                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.3 身份状态矩阵

| User 状态 | Escort 状态 | 显示内容 | 说明 |
|-----------|------------|---------|------|
| 未登录 | - | 普通访客界面 | 可浏览，不可下单 |
| 已登录 | 不存在 | 普通用户界面 | 可下单，无工作台 |
| 已登录 | pending | 普通用户界面 + 审核提示 | 等待审核 |
| 已登录 | active | 普通用户界面 + 工作台入口 | 双重身份 |
| 已登录 | inactive | 普通用户界面 | 陪诊员已停用 |
| 已登录 | suspended | 普通用户界面 + 封禁提示 | 陪诊员被封禁 |

---

## 二、数据模型

### 2.1 用户表（User）

```prisma
model User {
  id              String    @id @default(uuid())
  
  // 登录信息
  phone           String?   @unique              // 手机号（绑定后）
  openId          String?   @unique @map("open_id")  // 微信 OpenID
  unionId         String?   @map("union_id")     // 微信 UnionID
  
  // 基本信息
  nickname        String?
  avatar          String?
  
  // 状态
  status          String    @default("active")   // active, disabled
  
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  lastLoginAt     DateTime? @map("last_login_at")
  
  // 关联
  escort          Escort?                        // 陪诊员身份（0或1）
  patients        Patient[]                      // 就诊人
  orders          Order[]                        // 订单
  
  @@map("users")
}
```

### 2.2 关联字段（Escort）

```prisma
model Escort {
  // ...
  userId    String?   @unique @map("user_id")  // 一对一关联
  user      User?     @relation(fields: [userId], references: [id])
  // ...
}
```

---

## 三、业务逻辑

### 3.1 手机号绑定触发

```typescript
// 用户绑定手机号时的处理逻辑
async function bindPhone(userId: string, phone: string): Promise<BindResult> {
  // 1. 检查手机号是否已被其他用户绑定
  const existingUser = await prisma.user.findUnique({
    where: { phone }
  });
  
  if (existingUser && existingUser.id !== userId) {
    throw new ConflictException('该手机号已被其他账号绑定');
  }
  
  // 2. 更新用户手机号
  await prisma.user.update({
    where: { id: userId },
    data: { phone }
  });
  
  // 3. 尝试绑定陪诊员身份
  const escortBindResult = await tryBindEscort(userId, phone);
  
  return {
    success: true,
    isEscort: escortBindResult.bound,
    escortStatus: escortBindResult.status,
  };
}

async function tryBindEscort(userId: string, phone: string): Promise<EscortBindResult> {
  // 查找手机号对应的陪诊员记录
  const escort = await prisma.escort.findUnique({
    where: { phone }
  });
  
  if (!escort) {
    return { bound: false };
  }
  
  if (escort.userId) {
    // 已经绑定了其他用户
    if (escort.userId !== userId) {
      console.warn(`陪诊员 ${escort.id} 已绑定其他用户 ${escort.userId}`);
      return { bound: false };
    }
    // 已经绑定当前用户
    return { bound: true, status: escort.status };
  }
  
  // 执行绑定
  await prisma.escort.update({
    where: { id: escort.id },
    data: { userId }
  });
  
  // 发送绑定成功通知
  await sendNotification({
    userId,
    type: 'escort_bound',
    data: {
      escortName: escort.name,
      status: escort.status,
    }
  });
  
  return { bound: true, status: escort.status };
}
```

### 3.2 身份检测 API

```typescript
// GET /escort/profile - 检测当前用户是否为陪诊员
async function getEscortProfile(userId: string): Promise<Escort | null> {
  const escort = await prisma.escort.findFirst({
    where: { userId },
    include: {
      hospitals: {
        include: { hospital: true }
      }
    }
  });
  
  if (!escort) {
    throw new NotFoundException('您不是陪诊员');
  }
  
  // 解析 JSON 字段
  return {
    ...escort,
    tags: escort.tags ? JSON.parse(escort.tags) : [],
    certificates: escort.certificates ? JSON.parse(escort.certificates) : [],
  };
}
```

### 3.3 身份解绑

```typescript
// 管理员或系统解绑陪诊员身份
async function unbindEscort(escortId: string, reason: string): Promise<void> {
  const escort = await prisma.escort.findUnique({
    where: { id: escortId }
  });
  
  if (!escort || !escort.userId) {
    return;
  }
  
  // 检查是否有进行中的订单
  const activeOrders = await prisma.order.count({
    where: {
      escortId,
      status: { in: ['assigned', 'arrived', 'in_progress'] }
    }
  });
  
  if (activeOrders > 0) {
    throw new BadRequestException('有进行中的订单，无法解绑');
  }
  
  // 解绑
  await prisma.escort.update({
    where: { id: escortId },
    data: { userId: null }
  });
  
  // 记录日志
  await createAuditLog({
    type: 'escort_unbound',
    escortId,
    userId: escort.userId,
    reason,
  });
}
```

### 3.4 手机号变更处理

```typescript
// 陪诊员更换手机号时的处理
async function changeEscortPhone(escortId: string, newPhone: string): Promise<void> {
  const escort = await prisma.escort.findUnique({
    where: { id: escortId }
  });
  
  // 1. 检查新手机号是否已被使用
  const existingEscort = await prisma.escort.findUnique({
    where: { phone: newPhone }
  });
  
  if (existingEscort && existingEscort.id !== escortId) {
    throw new ConflictException('该手机号已被其他陪诊员使用');
  }
  
  // 2. 检查是否有用户使用新手机号
  const newUser = await prisma.user.findUnique({
    where: { phone: newPhone }
  });
  
  await prisma.$transaction(async (tx) => {
    // 3. 更新陪诊员手机号
    await tx.escort.update({
      where: { id: escortId },
      data: { 
        phone: newPhone,
        userId: newUser?.id ?? null  // 如果有新用户，自动绑定
      }
    });
    
    // 4. 如果原来有绑定的用户，解除关联
    // 注意：用户的手机号不变，只是陪诊员记录变了
  });
}
```

---

## 四、前端实现

### 4.1 身份检测 Hook

```typescript
// miniapp/src/hooks/useEscortIdentity.ts

import { useState, useEffect } from 'react';
import { get } from '@/services/request';
import { isLoggedIn } from '@/services/request';

interface EscortIdentity {
  isEscort: boolean;
  escortInfo: Escort | null;
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
}

export function useEscortIdentity(): EscortIdentity {
  const [isEscort, setIsEscort] = useState(false);
  const [escortInfo, setEscortInfo] = useState<Escort | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const checkIdentity = async () => {
    if (!isLoggedIn()) {
      setIsEscort(false);
      setEscortInfo(null);
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      const data = await get('/escort/profile');
      if (data?.id) {
        setIsEscort(true);
        setEscortInfo(data);
      } else {
        setIsEscort(false);
        setEscortInfo(null);
      }
    } catch (err) {
      // 404 表示不是陪诊员，不算错误
      if (err.statusCode !== 404) {
        setError(err);
      }
      setIsEscort(false);
      setEscortInfo(null);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    checkIdentity();
  }, []);

  return {
    isEscort,
    escortInfo,
    loading,
    error,
    refresh: checkIdentity,
  };
}
```

### 4.2 个人中心入口渲染

```tsx
// miniapp/src/pages/user/index.tsx

import { useEscortIdentity } from '@/hooks/useEscortIdentity';

export default function UserCenter() {
  const { isEscort, escortInfo, loading } = useEscortIdentity();
  
  return (
    <View className='user-page'>
      {/* 用户信息卡片 */}
      <UserInfoCard />
      
      {/* 陪诊员入口 - 仅陪诊员可见 */}
      {!loading && isEscort && (
        <View 
          className='escort-entry-card'
          onClick={() => Taro.navigateTo({ url: '/pages/workbench/index' })}
        >
          <View className='entry-left'>
            <Icon name='briefcase' size={24} color='#f97316' />
            <View className='entry-text'>
              <Text className='entry-title'>陪诊员工作台</Text>
              <Text className='entry-desc'>
                {escortInfo?.workStatus === 'working' ? '接单中' : '休息中'}
              </Text>
            </View>
          </View>
          <Icon name='chevron-right' size={20} color='#999' />
        </View>
      )}
      
      {/* 审核中提示 */}
      {!loading && escortInfo?.status === 'pending' && (
        <View className='escort-pending-tip'>
          <Icon name='clock' size={16} color='#faad14' />
          <Text>您的陪诊员申请正在审核中</Text>
        </View>
      )}
      
      {/* 其他菜单 */}
      <UserMenuList />
    </View>
  );
}
```

### 4.3 TabBar 动态显示

```tsx
// 方案一：在个人中心内嵌入口（推荐）
// 见上方代码

// 方案二：动态 TabBar（需要自定义 TabBar）
// miniapp/src/components/CustomTabBar/index.tsx

export default function CustomTabBar() {
  const { isEscort } = useEscortIdentity();
  
  const tabs = [
    { path: '/pages/index/index', title: '首页', icon: 'home' },
    { path: '/pages/services/index', title: '服务', icon: 'grid' },
    { path: '/pages/orders/index', title: '订单', icon: 'clipboard-list' },
    { path: '/pages/user/index', title: '我的', icon: 'user' },
    // 陪诊员专属 Tab
    ...(isEscort ? [{
      path: '/pages/workbench/index',
      title: '工作台',
      icon: 'briefcase',
    }] : []),
  ];
  
  // ...
}
```

---

## 五、API 设计

### 5.1 身份相关 API

| 方法 | 端点 | 说明 | 权限 |
|------|------|------|------|
| GET | `/escort/profile` | 获取当前用户的陪诊员信息 | 用户 |
| GET | `/escort/identity-status` | 获取身份状态（简化版） | 用户 |

### 5.2 管理端 API

| 方法 | 端点 | 说明 | 权限 |
|------|------|------|------|
| POST | `/admin/escorts/:id/bind` | 手动绑定用户 | 管理员 |
| POST | `/admin/escorts/:id/unbind` | 解除绑定 | 管理员 |

### 5.3 接口响应

```typescript
// GET /escort/identity-status 响应
interface IdentityStatusResponse {
  isEscort: boolean;
  status?: 'pending' | 'active' | 'inactive' | 'suspended';
  workStatus?: 'resting' | 'working' | 'busy';
  name?: string;
  level?: string;
}

// GET /escort/profile 响应
interface EscortProfileResponse {
  id: string;
  name: string;
  phone: string;
  avatar?: string;
  level: string;
  status: string;
  workStatus: string;
  rating: number;
  orderCount: number;
  tags: string[];
  hospitals: Array<{
    id: string;
    hospitalId: string;
    hospital: { id: string; name: string };
    familiarDepts: string[];
    isPrimary: boolean;
  }>;
}
```

---

## 六、异常处理

### 6.1 常见异常场景

| 场景 | 处理方式 |
|------|---------|
| 手机号冲突 | 提示用户联系客服处理 |
| 陪诊员已绑定其他用户 | 管理员介入解绑 |
| 用户更换手机号 | 自动解除原陪诊员绑定 |
| 陪诊员被封禁 | 用户端显示提示，无法进入工作台 |

### 6.2 日志记录

```typescript
// 身份变更审计日志
interface IdentityAuditLog {
  id: string;
  type: 'escort_bound' | 'escort_unbound' | 'phone_changed';
  escortId: string;
  userId?: string;
  oldPhone?: string;
  newPhone?: string;
  reason?: string;
  operatorId?: string;  // 操作人（管理员操作时）
  createdAt: Date;
}
```

---

## 七、验收标准

- [ ] 管理员创建陪诊员后，用户绑定相同手机号自动关联
- [ ] 用户登录后能正确识别陪诊员身份
- [ ] 个人中心正确显示/隐藏工作台入口
- [ ] 不同状态的陪诊员显示对应的提示信息
- [ ] 管理员可手动绑定/解绑陪诊员身份
- [ ] 身份变更有完整的日志记录
