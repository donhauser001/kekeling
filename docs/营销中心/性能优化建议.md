# 营销中心性能优化建议

## 一、数据库优化

### 1.1 索引优化

#### 价格计算相关查询
```sql
-- 用户会员查询（频繁查询）
CREATE INDEX idx_user_membership_user_status ON "UserMembership"("userId", "status");

-- 活动查询（按时间范围）
CREATE INDEX idx_campaign_status_dates ON "Campaign"("status", "startAt", "endAt");

-- 优惠券查询（用户可用优惠券）
CREATE INDEX idx_user_coupon_user_status ON "UserCoupon"("userId", "status", "expireAt");

-- 积分记录查询（用户积分明细）
CREATE INDEX idx_point_record_user_type ON "PointRecord"("userId", "type", "createdAt");

-- 邀请记录查询（邀请统计）
CREATE INDEX idx_referral_record_inviter ON "ReferralRecord"("inviterId", "status", "createdAt");
```

#### 订单价格快照查询
```sql
-- 订单价格快照（用于追溯）
CREATE INDEX idx_order_price_snapshot_order ON "OrderPriceSnapshot"("orderId");
```

### 1.2 查询优化

#### 价格计算查询优化
- 使用 `findFirst` 而不是 `findMany` 获取单个配置
- 使用 `select` 只查询需要的字段
- 避免 N+1 查询，使用 `include` 或 `select` 一次性获取关联数据

#### 优惠券列表查询优化
```typescript
// 优化前
const coupons = await prisma.userCoupon.findMany({
  where: { userId, status: 'unused' },
})

// 优化后
const coupons = await prisma.userCoupon.findMany({
  where: { 
    userId, 
    status: 'unused',
    expireAt: { gte: new Date() } // 只查询未过期的
  },
  select: {
    id: true,
    name: true,
    type: true,
    value: true,
    expireAt: true,
    // 只选择需要的字段
  },
  take: 20, // 限制数量
})
```

### 1.3 批量操作优化

#### 定时任务批量更新
```typescript
// 优化前：逐条更新
for (const membership of expiredMemberships) {
  await prisma.userMembership.update({
    where: { id: membership.id },
    data: { status: 'expired' },
  })
}

// 优化后：批量更新
await prisma.userMembership.updateMany({
  where: {
    status: 'active',
    expiresAt: { lt: new Date() },
  },
  data: { status: 'expired' },
})
```

## 二、API 性能优化

### 2.1 价格计算优化

#### 缓存配置数据
```typescript
// 使用 Redis 缓存价格配置（变更频率低）
const pricingConfig = await redis.get('pricing:config')
if (!pricingConfig) {
  const config = await prisma.pricingConfig.findFirst()
  await redis.set('pricing:config', JSON.stringify(config), 'EX', 3600)
}
```

#### 并行查询
```typescript
// 优化前：串行查询
const membership = await prisma.userMembership.findFirst(...)
const campaign = await prisma.campaign.findFirst(...)
const coupon = await prisma.userCoupon.findFirst(...)

// 优化后：并行查询
const [membership, campaign, coupon] = await Promise.all([
  prisma.userMembership.findFirst(...),
  prisma.campaign.findFirst(...),
  prisma.userCoupon.findFirst(...),
])
```

### 2.2 列表查询优化

#### 分页查询
```typescript
// 使用 cursor-based pagination 代替 offset pagination
const coupons = await prisma.userCoupon.findMany({
  where: { userId, status: 'unused' },
  cursor: { id: lastId },
  take: 20,
  orderBy: { id: 'asc' },
})
```

#### 延迟加载
```typescript
// 只加载必要的数据，其他数据按需加载
const couponList = await prisma.userCoupon.findMany({
  select: {
    id: true,
    name: true,
    type: true,
    value: true,
    // 不加载详细信息
  },
})
```

### 2.3 响应压缩

```typescript
// 启用 gzip 压缩
import compression from 'compression'
app.use(compression())
```

## 三、定时任务优化

### 3.1 批量处理

```typescript
// 优化前：逐条处理
const memberships = await prisma.userMembership.findMany({
  where: { status: 'active', expiresAt: { lt: new Date() } },
})
for (const membership of memberships) {
  await processMembership(membership)
}

// 优化后：批量处理
const memberships = await prisma.userMembership.findMany({
  where: { status: 'active', expiresAt: { lt: new Date() } },
  take: 1000, // 分批处理
})
await prisma.userMembership.updateMany({
  where: { id: { in: memberships.map(m => m.id) } },
  data: { status: 'expired' },
})
```

### 3.2 任务调度优化

```typescript
// 使用 cron 表达式精确控制执行时间
// 避免在高峰期执行
@Cron('0 2 * * *') // 每天凌晨 2 点执行
async checkMembershipExpiration() {
  // ...
}
```

### 3.3 增量处理

```typescript
// 只处理需要更新的数据
const expiredMemberships = await prisma.userMembership.findMany({
  where: {
    status: 'active',
    expiresAt: {
      gte: new Date(Date.now() - 24 * 60 * 60 * 1000), // 只查询最近 24 小时过期的
      lt: new Date(),
    },
  },
})
```

## 四、缓存策略

### 4.1 Redis 缓存

#### 缓存热点数据
```typescript
// 会员等级列表（变更频率低）
const levels = await redis.get('membership:levels')
if (!levels) {
  const data = await prisma.membershipLevel.findMany()
  await redis.set('membership:levels', JSON.stringify(data), 'EX', 3600)
}

// 活动列表（变更频率中等）
const campaigns = await redis.get('campaigns:active')
if (!campaigns) {
  const data = await prisma.campaign.findMany({
    where: { status: 'active' },
  })
  await redis.set('campaigns:active', JSON.stringify(data), 'EX', 300)
}
```

#### 缓存用户数据
```typescript
// 用户会员信息（变更频率低）
const membership = await redis.get(`membership:user:${userId}`)
if (!membership) {
  const data = await prisma.userMembership.findFirst({
    where: { userId, status: 'active' },
  })
  await redis.set(`membership:user:${userId}`, JSON.stringify(data), 'EX', 600)
}
```

### 4.2 缓存失效策略

```typescript
// 当数据更新时，清除相关缓存
async updateMembership(userId: string, data: any) {
  await prisma.userMembership.update({ where: { userId }, data })
  await redis.del(`membership:user:${userId}`) // 清除缓存
}
```

## 五、并发控制

### 5.1 秒杀库存控制

```typescript
// 使用数据库锁防止超卖
await prisma.$transaction(async (tx) => {
  const item = await tx.seckillItem.findUnique({
    where: { id },
    select: { stockRemaining: true },
  })
  
  if (item.stockRemaining <= 0) {
    throw new Error('库存不足')
  }
  
  await tx.seckillItem.update({
    where: { id },
    data: { stockRemaining: { decrement: 1 } },
  })
})
```

### 5.2 分布式锁

```typescript
// 使用 Redis 分布式锁
import Redlock from 'redlock'

const redlock = new Redlock([redis], {
  retryCount: 3,
  retryDelay: 200,
})

async claimCoupon(userId: string, templateId: string) {
  const lock = await redlock.acquire([`coupon:${templateId}`], 1000)
  try {
    // 检查限制
    // 创建优惠券
  } finally {
    await lock.release()
  }
}
```

## 六、监控与告警

### 6.1 性能监控

```typescript
// 记录 API 响应时间
import { performance } from 'perf_hooks'

async calculatePrice(...) {
  const start = performance.now()
  // ... 计算逻辑
  const duration = performance.now() - start
  
  if (duration > 500) {
    logger.warn(`Price calculation slow: ${duration}ms`)
  }
}
```

### 6.2 错误监控

```typescript
// 记录错误并告警
try {
  await processOrder()
} catch (error) {
  logger.error('Order processing failed', { error, orderId })
  // 发送告警
  await sendAlert('订单处理失败', { orderId, error })
}
```

## 七、代码优化建议

### 7.1 避免不必要的计算

```typescript
// 优化前：每次都计算
const price = await calculatePrice(...)
if (price.finalPrice > 0) {
  // ...
}

// 优化后：提前判断
if (!serviceId || !userId) {
  throw new Error('参数错误')
}
const price = await calculatePrice(...)
```

### 7.2 使用适当的数据结构

```typescript
// 使用 Map 代替数组查找
const couponMap = new Map(coupons.map(c => [c.id, c]))
const coupon = couponMap.get(couponId) // O(1) 查找
```

### 7.3 减少数据库查询

```typescript
// 优化前：多次查询
const membership = await prisma.userMembership.findFirst(...)
const level = await prisma.membershipLevel.findUnique(...)

// 优化后：一次查询
const membership = await prisma.userMembership.findFirst({
  include: { level: true },
})
```

## 八、部署优化

### 8.1 数据库连接池

```typescript
// 配置连接池大小
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
  // 连接池配置
})
```

### 8.2 负载均衡

- 使用负载均衡器分发请求
- 配置健康检查
- 实现请求限流

### 8.3 CDN 加速

- 静态资源使用 CDN
- API 响应缓存（适合变更频率低的数据）

## 九、测试建议

### 9.1 压力测试

- 使用 Apache Bench 或 wrk 进行压力测试
- 测试并发下单场景
- 测试秒杀场景

### 9.2 性能基准

- API 响应时间 < 500ms（P95）
- 数据库查询时间 < 100ms（P95）
- 定时任务执行时间 < 5s

## 十、持续优化

1. **定期审查慢查询**：使用 PostgreSQL 的 `pg_stat_statements` 分析慢查询
2. **监控关键指标**：响应时间、错误率、数据库连接数
3. **定期优化索引**：根据查询模式调整索引
4. **代码审查**：避免 N+1 查询、不必要的计算

